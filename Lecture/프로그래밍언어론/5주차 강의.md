# 5주차 강의

* Dynamic Scoping은 실행되기 전 까지는 오류가 검출되지 않아서 불확실하다 (파악하기 쉽지 않음)



### Implementing Scope

* symbol table
  * 이름과 어떤 값(함수)을 관리해주는 표 (dictionary)
* 새로운 mapping을 추가 (name to object binding)
* 주어진 이름에 Lookup the information
* symbol table에서 제거

![image-20200928123725474](./figure/enter_scope)

### The meaning of Names within a Scope

* aliases
  * 두개 혹은 그 이상의 이름이 같은 오브젝트를 가리키는 형태
* Overloaded (<-> aliases)
  * 하나의 이름이 여러개의 오브젝트를 가리키는 형태
  * 다형성과 관련있음

```c
double sum. sumOfSquares;
//double& y = sum;
void accumulate(double& x){
    sum+=x;
    sumOfSquares += (x*x);
}

sum = 4;
accumulate(sum);
```

* sum에 4를 넣어줄 경우 accumalate 함수에서 가리키는 x는 sum의 주소를 가리키기 때문에 함수 내에 sum은 8 이되고, sumOfSquares는 64가 된다. 

* c++ 에 참조형은 aliases를 만드는것, 포인터형은 값을 복사하는 것 (같은 이름을 쓴다고 해서 같은 내용이 아님!)
* java 는 aliases 타입이 아예 존재 하지 않는다



#### Overloading

* +연산자는 동작하는 방식이 비슷함 (사실은 overloading의 개념?)

  * ex) 2+3 = 5 /  2.3+3 = 5.3 / 2.3+3.0 = 5.3

    * 다양한 타입에 대해 + 연산자를 사용했을 때 적절한 타입을 반환해줌 --> Overloading!

    * int 와 int를 받는 연산자, int 와 double 받는 연산자, double과 double을 받는 연산자

    * ```java
      int add(int a, int b);
      double add(int a, double b);
      double add(double a, double b);
      ...
      ```

* 명확하게 지정할 수 있도록 context를 지정해준다.
  * `print(month'(oct));` / `print(print_base.oct);// c++`

