# 5주차 강의

* Dynamic Scoping은 실행되기 전 까지는 오류가 검출되지 않아서 불확실하다 (파악하기 쉽지 않음)



### Implementing Scope

* symbol table
  * 이름과 어떤 값(함수)을 관리해주는 표 (dictionary)
* 새로운 mapping을 추가 (name to object binding)
* 주어진 이름에 Lookup the information
* symbol table에서 제거

![image-20200928123725474](./figure/enter_scope)

### The meaning of Names within a Scope

* aliases
  * 두개 혹은 그 이상의 이름이 같은 오브젝트를 가리키는 형태
* Overloaded (<-> aliases)
  * 하나의 이름이 여러개의 오브젝트를 가리키는 형태
  * 다형성과 관련있음

```c
double sum. sumOfSquares;
//double& y = sum;
void accumulate(double& x){
    sum+=x;
    sumOfSquares += (x*x);
}

sum = 4;
accumulate(sum);
```

* sum에 4를 넣어줄 경우 accumalate 함수에서 가리키는 x는 sum의 주소를 가리키기 때문에 함수 내에 sum은 8 이되고, sumOfSquares는 64가 된다. 

* c++ 에 참조형은 aliases를 만드는것, 포인터형은 값을 복사하는 것 (같은 이름을 쓴다고 해서 같은 내용이 아님!)
* java 는 aliases 타입이 아예 존재 하지 않는다



#### Overloading

* +연산자는 동작하는 방식이 비슷함 (사실은 overloading의 개념?)

  * ex) 2+3 = 5 /  2.3+3 = 5.3 / 2.3+3.0 = 5.3

    * 다양한 타입에 대해 + 연산자를 사용했을 때 적절한 타입을 반환해줌 --> Overloading!

    * int 와 int를 받는 연산자, int 와 double 받는 연산자, double과 double을 받는 연산자

    * ```java
      int add(int a, int b);
      double add(int a, double b);
      double add(double a, double b);
      ...
      ```

* 명확하게 지정할 수 있도록 context를 지정해준다.
  
  * `print(month'(oct));` / `print(print_base.oct);// c++`

#### Redefining Built-in Operators

* +,-,*,etc.. 등등 오버로딩 가능 --> C++,C#,Ada.. (대부분의 객체지향언어들)

* 두 값 사이에 사이에 연산자가 나오는것 : infix (A+B)
  * Syntatic Sugar (더 쓰기 쉽잖아~)
* 연산자가 먼저 나오는 것 : prefix form > (  "+"(A,B)  )

```c++
class complex{
    double real, imaginary;
public:
    complex operator+(complex other){
        return complex(real+other.real,imaginary+other.imaginaray)
    }
}
complex A,B,C
C = A+B; // User-Defined operator +
```

* Haskell 언어에서 User-Defined infix operators

  ```haskell
  let a @@ b = a * 2 + b
  let (@@) a b = a * 2 + b
  
  3 @@ 4 ==> 10
  (@@) 3 4 ==> 10
  ```

* Coercion - 자동 형변환
  * `double d2 = 3.0f` : float을 자동으로 double 로 형변환해줌
  * 한 가지 함수에 여러가지 타입의 인자를 줄 수 있다.

* Polymorphism - 다형성 : single subroutine 에서 여러가지 타입의 인자를 받을 수 있다.

  * 한 가지 함수를 만들어 놓고 여러가지 자료형을 전달 할 수 있다.

     ```c++
    상속받은 print(B b)함수
    print(A a) // A 라는 객체를 입력받게 함 (Over Loading)
    ```

    * 위 상황에서 상속받은 `print(B b)` 함수도 사용이 가능하다

* 두 개념 모두 오버로딩과 관련 있따.
* Overloading,Coercion,polymorphism 모두 다 특정한 상황에 놓여 있을 때, 
  여러가지 자료형의 타입의 인자들을 전달하는 것이 가능, 
  여러가지 종류의 타입의 값들을 반환하는 것이 가능
* 한 가지 이름을 가지고 있는 코드에 대해서, 여러가지 자료형을 인자를 전달할 수 있다.
  * Overloading 처럼 보일 수 있으나, Coercion, Polymorphism 인 경우일 수도 있다.
    * 자료형, 자료형의 갯수 등을 가지고 구별함



* `toString()`
  * polymorphic print routine
  * 우리가 흔히 `System.out.println(object o)`를 사용할 때, o에 있는 toString() 함수를 호출하는 것임
    * 이 toString() 함수를 Overloading 할 수 있다.



### Referencing Environments

##### Static Scope Rules

* compile time에 체크 가능

##### Dynamic Scope Rules

* run time 에 체크가 가능

> 함수를 파라미터,인자로 넘길 때 subroutine에 대한 참조를 생성할 수 있도록 해주는데,
>
> Scope 규칙을 따졌을 때, 어떤 것을 적용시켜야 하는가?
>
> Reference is first created ? --> 처음 생성되었을 때?
>
> or 
>
> Routine is finally Called ? --> 마지막으로 불렸을 때?
>
> --> 언어마다 정하는 것이 다름

```c
typedef struct{
    int age;
} person;

int threshold;
database people;

int older_than_threshold(person p){
    return p.age >= threshold;
}
void print_person(person p){
   print Person using Line Length
}
void print_selected_records(database db,function predicate, function print_routine){
    int line_length;
    if(device_type(stdout) == terminal)
        line_length= 80
    else
        line_length = 132
        
    foreach record r in db{
        if predicate(r)
            print_routine(r);
    }
}
int main(void){
    threshold= 35;
    print_selected_records(people,order_than_threshold,print_person);
}
```

* `print_selected_records` - 데이터베이스 안에 있는 내용이 뭔진 모르지만 요소 1개를 record 타입으로 빼서 `order_than_threshold` 수행
  *  people : DB
  * order_than_threshold : 출력할 사람들을 걸러내 주는 것
    * 위 코드 예시는 threshold보다 높은 age를 가진 person을 선별
  * print_person : 출력
* 이 `print_selected_records`에 인자만 바꿔서 threshold보다 높은 age를 가진 사람을 선별하는 함수가 되는 것이다 --> 일반화시킨 함수를 만들고 활용
* Dynamic Scoping을 사용하는 경우
  * `print_selected_record`는 `line length` 변수를 초기화 시켜주어야 print_routine 에서 사용할 수 있음
  * Static인 경우 전역변수로 빼내야 함
  * Routine is finally Called 에 해당하는 내용임
  * `print_selected_record` 에서 실제로 사용하기 직전까지 reference environment는 만들어지면 안된다.
    * 불려지기 전에 만들어져야한다.
    * subroutine이 파라미터로써 전달될 때, Reference environment를 불려지기 직전에 만들어져서 사용되는 것(Late Binding)
      * 이 Late Binding 을 사용하는 것을 Shallow Binding
      * Dynamic Scoping을 사용하는 언어들 중에서 shallow binding이 사용됨
* `older_than_threshold`에서 shallow binding이 제대로 작동되지 않을 수 있다
  * threshold라는 변수가 `print_selected_record` 함수 내에 또 만들어지면 문제가 생길 수 있다.
  * Dynamic Scoping이면 함수 내에 만들어진 Threshold가 사용된다는 것이다
  * 내가 모르는 사이에 shallow binding이 적용이 안될 수도 있다는 뜻
  * 함수를 호출될 때 파라미터로 refernece environment를 담아간다. --> Deep Binding

##### Deep Binding

* `order_than_threshold`가 실제로 호출 될 때, 함수가 처음 pass가 될 때 만들어 졌던 reference environment를 사용하는 것
* Early Binding 이라고도 함 (shallow binding은 late binding..)
  * static scoped language는 default로 사용
    * 함수가 처음 생성됐을 때 그때 만들어진 reference environment를 사용함
  * dynamic scoped language인 언어도 option으로 사용 가능 (default = shallow binding)
    * subroutine이 실제로 호출 될때 만들어진 바인딩,reference environment를 사용함



### Subroutine Closure

* 함수에 대한 reference와, referencing envrionment와 묶어 놓은 것
  * 함수가 배낭(reference environment를 담은) 을 메고 있는 함수..! = 클로져
* 클로져 자체 내에서 함수는 Code영역에 대한 포인터(주소값) 으로 표현되어 있는 경우가 많다.
* Lisp 언어에서, built-in primitive function을 가지고 호출할 때, 인자에 function을 전달함
  * 인자로 주어진 함수와 현재 호출될 때 당시의 reference environment를 합쳐서 closure를 생성 --> 반환
  * closure를 가지고 다른 함수 인자로 전달 가능

```python
def A(I,P):
    def B():
        print(I)
    if I > 1:
        P()
    else:
        A(2,B)
def C():
    pass
A(1,C)
```

* Shallow Binding
  * 2라는 값이 출력됨 (가장 최근에 만들어진 I가 2니까)
* Deep Binding
  * 1이 출력됨
  * A(2,B)에서 reference environment (I를) 1로 줌
  * 따라서 B()를 수행했을 때에는 1을 출력하는 것
  * 전달할 당시에 Reference Environment를 전달해야하므로 1이 전달되는 것

* Static Scoping인 경우에는 존재가 한개밖에 존재하지 않으므로, 내용 자체가 영향을 미치지 않는다.
  * 어디서 보든 똑같은 변수를 볼 것이다
  * 하지만 Nested 되어있는 함수가 있는 경우는 또 다른 문제가 발생함
* Deep,Shallow Binding은 Nested를 지원하는 언어, Dynamic Scoping이 사용되는 언어 등이 사용된다.

```c
void f(){
    int x;
}
void g(f f1){
    f1();
}
void m(){
    g(f)
}
```

* f()란 함수는 어디서 실행되나, int x는 f() 가 실행 될 때 만들어지므로 상관없음

```c
void f(){
    int x;
    void n(){
        ...
    }
    //reference environment(1)
    g(n)
}
void g(f f1){
    //reference environment(2)
    f1();
}
```

* (1)과 (2)는 다르다.
  * x라는 변수는, (1)에 포함되는데, (2)로가면 스택에서 보이지 않는 변수라 다를 수 있다.
  * Static Scope를 쓰는 경우 Nested 함수가 있는 경우에는..closure에 대한 이야기를 꺼낼 수 있다.

* 최근 언어 (Python, JS) 에서 Closure에 대한 이야기들이 많이 나옴



