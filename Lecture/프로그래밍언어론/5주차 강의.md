# 5주차 강의

* Dynamic Scoping은 실행되기 전 까지는 오류가 검출되지 않아서 불확실하다 (파악하기 쉽지 않음)



### Implementing Scope

* symbol table
  * 이름과 어떤 값(함수)을 관리해주는 표 (dictionary)
* 새로운 mapping을 추가 (name to object binding)
* 주어진 이름에 Lookup the information
* symbol table에서 제거

![image-20200928123725474](./figure/enter_scope)

### The meaning of Names within a Scope

* aliases
  * 두개 혹은 그 이상의 이름이 같은 오브젝트를 가리키는 형태
* Overloaded (<-> aliases)
  * 하나의 이름이 여러개의 오브젝트를 가리키는 형태
  * 다형성과 관련있음

```c
double sum. sumOfSquares;
//double& y = sum;
void accumulate(double& x){
    sum+=x;
    sumOfSquares += (x*x);
}

sum = 4;
accumulate(sum);
```

* sum에 4를 넣어줄 경우 accumalate 함수에서 가리키는 x는 sum의 주소를 가리키기 때문에 함수 내에 sum은 8 이되고, sumOfSquares는 64가 된다. 

* c++ 에 참조형은 aliases를 만드는것, 포인터형은 값을 복사하는 것 (같은 이름을 쓴다고 해서 같은 내용이 아님!)
* java 는 aliases 타입이 아예 존재 하지 않는다



#### Overloading

* +연산자는 동작하는 방식이 비슷함 (사실은 overloading의 개념?)

  * ex) 2+3 = 5 /  2.3+3 = 5.3 / 2.3+3.0 = 5.3

    * 다양한 타입에 대해 + 연산자를 사용했을 때 적절한 타입을 반환해줌 --> Overloading!

    * int 와 int를 받는 연산자, int 와 double 받는 연산자, double과 double을 받는 연산자

    * ```java
      int add(int a, int b);
      double add(int a, double b);
      double add(double a, double b);
      ...
      ```

* 명확하게 지정할 수 있도록 context를 지정해준다.
  
  * `print(month'(oct));` / `print(print_base.oct);// c++`

#### Redefining Built-in Operators

* +,-,*,etc.. 등등 오버로딩 가능 --> C++,C#,Ada.. (대부분의 객체지향언어들)

* 두 값 사이에 사이에 연산자가 나오는것 : infix (A+B)
  * Syntatic Sugar (더 쓰기 쉽잖아~)
* 연산자가 먼저 나오는 것 : prefix form > (  "+"(A,B)  )

```c++
class complex{
    double real, imaginary;
public:
    complex operator+(complex other){
        return complex(real+other.real,imaginary+other.imaginaray)
    }
}
complex A,B,C
C = A+B; // User-Defined operator +
```

* Haskell 언어에서 User-Defined infix operators

  ```haskell
  let a @@ b = a * 2 + b
  let (@@) a b = a * 2 + b
  
  3 @@ 4 ==> 10
  (@@) 3 4 ==> 10
  ```

* Coercion - 자동 형변환
  * `double d2 = 3.0f` : float을 자동으로 double 로 형변환해줌
  * 한 가지 함수에 여러가지 타입의 인자를 줄 수 있다.

* Polymorphism - 다형성 : single subroutine 에서 여러가지 타입의 인자를 받을 수 있다.

  * 한 가지 함수를 만들어 놓고 여러가지 자료형을 전달 할 수 있다.

     ```c++
    상속받은 print(B b)함수
    print(A a) // A 라는 객체를 입력받게 함 (Over Loading)
     ```

    * 위 상황에서 상속받은 `print(B b)` 함수도 사용이 가능하다

* 두 개념 모두 오버로딩과 관련 있따.
* Overloading,Coercion,polymorphism 모두 다 특정한 상황에 놓여 있을 때, 
  여러가지 자료형의 타입의 인자들을 전달하는 것이 가능, 
  여러가지 종류의 타입의 값들을 반환하는 것이 가능
* 한 가지 이름을 가지고 있는 코드에 대해서, 여러가지 자료형을 인자를 전달할 수 있다.
  * Overloading 처럼 보일 수 있으나, Coercion, Polymorphism 인 경우일 수도 있다.
    * 자료형, 자료형의 갯수 등을 가지고 구별함



* `toString()`
  * polymorphic print routine
  * 우리가 흔히 `System.out.println(object o)`를 사용할 때, o에 있는 toString() 함수를 호출하는 것임
    * 이 toString() 함수를 Overloading 할 수 있다.



### Referencing Environments

##### Static Scope Rules

* compile time에 체크 가능

##### Dynamic Scope Rules

* run time 에 체크가 가능

> 함수를 파라미터,인자로 넘길 때 subroutine에 대한 참조를 생성할 수 있도록 해주는데,
>
> Scope 규칙을 따졌을 때, 어떤 것을 적용시켜야 하는가?
>
> Reference is first created ? --> 처음 생성되었을 때?
>
> or 
>
> Routine is finally Called ? --> 마지막으로 불렸을 때?
>
> --> 언어마다 정하는 것이 다름

```c
typedef struct{
    int age;
} person;

int threshold;
database people;

int older_than_threshold(person p){
    return p.age >= threshold;
}
void print_person(person p){
}
void print_selected_records(database db,function predicate, function print_routine){
    int line_length;
    if(device_type(stdout) == terminal)
        line_length= 80
    else
        line_length = 132
        
    foreach record r in db{
        if predicate(r)
            print_routine(r);
    }
}
int main(void){
    threshold= 35;
    print_selected_records(people,order_than_threshold,print_person);
}
```

* `print_selected_records` - 데이터베이스 안에 있는 내용이 뭔진 모르지만 요소 1개를 record 타입으로 빼서 `order_than_threshold` 수행





