# 6주차 강의

## 5주차 복습

* Program을 강제로 멈췄을 때 사용할 수 있는 Reference, Scope를 유지하고 있는 변수 함수 등등.. ==> Reference Environment

* 함수가 인자로 전달되기 직전에 만들어져 있던 Reference Environment 사용하는 것 --> Deep binding
  * Closure 를 이용해서 구현
  * 전달되는 Subroutine이 배낭을 하나 메고가는 것 (배낭 안에는 Reference Environment를 가지고 있다)
  * 그것을 통째로 전달!
* 함수가 호출되기 직전에 만들어져 있던 Reference Environment 사용하는 것 --> Shallow Binding



## Frist-Class Values and Unlimited Extent



### First-Class Status(First-class Citizen..)

* value 는 First-Class Status를 가지고 있다

  * 인자로서 전달 가능

  * 함수에서 반환하는 자료형으로 사용할 수 있어야 한다

  * 변수에 저장할 수 있어야한다 (참조,저장..등등)

    > 3가지 를 만족시 First Class 수준(status) 라고한다.

* int, Char은 **First-Class Values** 

* Second-Class

  * 인자로 전달 가능
  * 변수 저장, 함수에서 반환 하는 것 둘 중에 하나는 안되야 함

* Third-Class

  * 인자로 전달 X

* Subroutine 이 First-Class로 취급이 가능한가?
  * 애매함, 특정 언어(함수형 언어)에서는 First-Class로 취급 --> C#, (제약이 있는 언어) --> C, C++ , Fortran, Modula, ada 95..
    * 함수를 인자로 넘기거나 함수로 반환하거나.. 또는 함수를 변수에 저장한다던가..
  * 대부분의 다른 imperative Language에서는 Second-class, Ada83 은 Third Class 취급

```lisp
(define plus-x
    (lambda(x)
           (lambda (y) (+ x y))))
(let ((f (plus-x 2)))
     (f 3))
```

* f라는 이름으로 plus-x 2를 넣음
* plus-x 2는 lambda (y) (+ x y) 를 반환한다 ==> lambda(y) (+ 2 y) 를 반환하게 되는 것
  * 위 람다함수가 f 라는 뜻
  * 여기서 lambda(y)(+ x y)를 반환할 때 x(=2)라는 변수는 유지가 됨
  * 함수가 반환이 될 때, **x는 지역변수 이므로 사라져야하는데, 유지가 된다**
    * 함수가 종료됨에도 불구하고 변수가 오랫동안 살아있다.
    * x는 어딘가에 살아있다! (x라는 변수는 Heap에 생성된다 --> 함수가 사라져도 남아있음)
    * lambda가 return할 당시에 reference environment를 가지고 반환한다.
      * 따라서 reference environment 내에는 x=2 가 존재함
* f(3)은 lambda(3) (+ 2 3) 을 말함
  * 결과는 5가 나옴
* Unlimited Extent : 라이프타임을 무제한으로 남게 한다.
  * Garbage Collection 동작할 경우 해당하는 변수가 사용되지 않을 때 없앤다.
* 대부분의 imperative language 는 함수안에 있는 변수,함수 들은 limited extent를 가지게 되는데
  - Closure를 사용하는 경우에 Unlimited Extent를 사용하게 됨



* Limited Extent를 가지고 있는 local object는 스택에 할당된다.
* Unlimited Extent를 가지고 있는 Local Object는 Heap에 할당된다.



```javascript
var globalVariable = "global";
function testClosure(){
    if (globalVariable == "global"){
        var t = document.getElementById("demo");
        t.innerText = "saw global";
    }
}
//브라우저가 처음 뜰 떄 해당 함수를 실행했으면 좋겠다!
window.onload = function(){ //anonymous Function
    testClosure();
}
```

* saw global을 출력



```javascript
var globalVariable = "global";
function testClosure(){
    var localvariable = "local"
    if (globalVariable == "global"){
        return function(){ //anonymous Function
        	var t = document.getElementById("demo");
            t.innerText = "saw " + localVariable;
        } // 이 경우 Reference Environment 안에 localvariable을 포함시켜서 반환함
    }
    else{
        return null;
    }
}
//브라우저가 처음 뜰 떄 해당 함수를 실행했으면 좋겠다!
window.onload = function(){ //anonymous Function
    var f = testClosure();
    if f == null{
        alert("globalVariable == null");
    }
    else{
        f();
    }
}
```

* 이 경우 saw local 을 출력
* testClosure()가 null을 반환하면 alert 수행



## Object Closure

```java
interface IntFunc{
    public int call(int j);
}
class PlusX implements IntFunc{
    final int x;
    PlusX(int n) { x= n ;}
    public int call(int i) { return i + x; }
}
..
IntFunc f = new PlusX(2);
System.out.println(f.call(3));
```

* 생성자에 x 에 대한 값 (2) 를 저장하고 call을 호출 했을 때 그 x에 대한 값을 가지고 call 함수를 호출 ==> 5를 출력
* 클래스 안에 멤버변수를 Context를 포함시킴 --> Object Closure



* 함수의 역할을 하는 Object , Object의 reference Environment ==> Object enclosure, Function Object , Functor
* delegate : C#에서의 interface 

* C# 2.0에서 anonymous methods에서 생성해서 반환하는 것이 가능

  ```c#
  static IntFunc PlusY(int y){
      return delegate(int i) { return i+y; }
  }
  IntFunc h = PlusY(2);
  h(3) ==> 5
  ```



```c++
class int_func{
public:
	virtual int operator()(int i) =0 ;    
};
class Plus_x : public int_func{
    const int x;
public:
    plus_x(int n) : x(n) {}
    virtual int operator(int i) {return i + x;}
}
plus_x f(2);
cout << f(3) << endl;
```

* plus_x f(2) ==> x에 2가 들어감
* f(3) ==> f는 객체의 이름인데 함수처럼 호출할 수 있음
  * 일반적으로 f.함수() 이런식으로 써야함..!
  * 마치 그 객체의 이름이 함수의 이름인 것처럼 호출 해준다.



## Lambda Expression

* 함수를 표현식으로 만들어서 전달하는 것
  * 장점 : 코드가 간결해짐!

```c#
static IntFunc PlusY(int y){
    return i => i+y;
}
```

* return delegate(int i) { return i+y; } 와 같은 코드 이다. 
* 유추할 수 있다면 타입을 안넣어줘도되지만, 유추할 수 없다면 타입을 꼭 넣어줘야한다.
* y라는 변수의 타입이 int라서 i가 int로 보여서 따로 타입을 넣어주진 않았음
* 여러개의 파라미터가 있다면 , 로 구분 가능
  함수를 반환하고 싶다 i => {} 코드블록으로 삽입 가능

* 최근 함수형 언어에서 Lambda를 도입하기 시작했다!
* Callback 함수에서 주로 사용되기 시작함
  * Sorting Routine
  * predicate
  * future event Handler

```c#
for_each(V.begin(), V.end(),
        [](int e) { if (e < 50) cout << e << " ";})
```

* for문이 해주는 작업을 함수가 해주는 것
  * 배열의 시작부터 끝까지!
  * 각각의 요소를 e라고 받았을 때, e에 대해 if문을 실행시켰으면 좋겠따! 라는 뜻
* 함수 대신에 간단한 표현식을 넣어서 함수처럼 쓰이는 것

ex)

* k가 lambda 밖에 있는 Scope 영역에 존재하는 경우

  ` [=] (int e) { if (e<k) cout << e << endl;}`  // 각각의 변수에 복사본을 넣고 비교

  ` [&] (int e) { if (e<k) cout << e << endl;}`  // 참조를 대신!
  이런 식으로 사용 할 수 있다 

* Java에서의 Lambda
  
  * Functional Interface 를 대체할 수 있다.

```java
class AgeComparator implements Comparator<person>{
    public int compare(person p1, person p2){
        return Integer.compare(p1.age,p2.age);
    }
}
person[] people = ... ;
Arrays.sort(people,new AgeCompartor());
//람다식 활용
Arrays.sort(people,
           (p1,p2) -> Integer.compare(p1.age,p2.age));
```

* `p1,p2` : 매개변수
* `Integer.compare(p1.age,p2.age)` : 코드의 Body부분
  * 타입의 유추가 가능하므로 타입을 안써줘도됨 (person 타입)

* 함수의 메소드를 넘기는 것처럼 보이지만, 컴파일러가 앞뒤로 클래스를 생성해주는 작업들을 한다.



### Java Lambda Expression

* 자바의 쓰레드를 사용하는 한가지 방법은 Runnable
  * `interface runnable{void run();}`
  * Runnable을 구현하는 클래스는 Thread 클래스의 생성자로 전달되어 실행가능

```java
class ThreadRunnable implements Runnable{
    @Override
    public void run(){
        System.out.println("Thread runs...");
    }
}
Thread t = new Thread(new ThreadRunnable());
t.run(); //쓰레드 실행
```

* 여러번 사용하는 경우 class를 만드는게 맞지만, 한번만 생성하고 안쓰는 경우 Class를 만들 필요 없이 Lambda 로 사용

```java
// 익명 클래스
Thread t = new Thread(new Runnable(){
    @Override
    public void run(){...}
});
// 람다식 구현
Thread t = new Thread(() -> system.out.println(".."));
t.run();
```



## Macro Expansion

* 자주 쓰는 코드를 매크로 형태로 만들어서 쓰는 것을 의미
* 반복되는 코드를 짧게 표현할 수 있도록 해준다.
* 어셈블리 언어에서 주로 사용

```c
// C 언어
#define LINE_LEN 80
#define DIVIDES(a,n) (!((n)%(a)))
#define SWAP(a,b) {int t = (a); (a) = (b); (b) = t}
#define MAX(a,b) ((a) > (b) ? (a) : (b))

DIVIDES(y+z,x) --> (!(x%y+z)); //있는대로 넘기면 문제가 생김 (y+Z)로 괄호를 쳐줘야함
SWAP(x,t);
MAX(x++,y++); //((x++) > (y++) ? (x++) : (y++)) --> 내가 생각했던 x,y값이 아님
```

* 매크로 함수의 장점은 타입의 구애 받지 않는다.

* Modern Languages 에서는 Macro를 안쓴다
  * C언어 에서의 매크로 함수는 위험함..!
  * in-line subroutines, named constants 같은 걸로 쓰인다.
    * `const int a =3;` : C언어에서는 read only 변수를 선언한다는 의미
* Scheme 이나 Common Lisp 언어는 매크로 언어를 안전하게 사용하게 해준다.

