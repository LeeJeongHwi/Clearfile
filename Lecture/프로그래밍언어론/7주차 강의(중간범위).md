# 7주차 강의

* 해당 범위 까지 중간고사



## Control Flow (제어 흐름)

* 반복문, 조건문 등등
* Sequencing - 순차적 실행
* selection (alternation) - 선택 , 조건문
  * if, switch, case
* iteration - 반복문
* procedural abstraction
* recursion
* Exception Handling
  * 예외상황 처리 코드 실행
    * program fragment 가 실행될 때에는 긍정적으로 실행시키는데, (문제가 없을꺼야~~~)
      경우에 따라 그렇지 않은 경우도 있다. (예상과 다른 결과)
      --> 오류 발생
    * 정해진 코드를 실행함
* Speculation
  * undo : 여태 실행해왔던 작업을 roll back
  * 이전 상태로 되돌리는 것
* concurrency
  * 2개 또는 그 이상의 fragment가 **동시에** 동작하는것
  * parallel 하게 실행 되느냐, interleaved 하게 실행되느냐
    * parallel : 병렬 처리
    * interleaved : 병행 처리
* nondeterminacy
  * statement나 expressions을 실행시키는데, 실행시키는 순서가 정확하게 정해져있지 않는 경우를 나타냄
  * 어떤 순서로 실행이 되든간에 맞는 결과를 나타낸다!
    * 실행순서를 명확하게 정해지지 않은 경우가 있다 (의도적으로)
    * 하지만 결과는 똑같이 나와야함!

## Expression Evaluation

* expression : 표현식 - 값을 만들어 내는 코드의 조각 , 값이 결과로 나오는 코드 조각
  * Simple Object - literal constant(상수), named variable( a, b 라는 상수 ), constant
    * `int a = 3; const int b = 4;`
    * a는 변수 , b는 c++에서는 상수  
  * Function 도 Expression

* operator (연산자)

  * built-in functions 라고 함
  * 간단한 형태의 새로운 문법 구조를 갖추고 있는 그러한 코드 fragment
  * 덧셈 뺼셈, shift , index 연산자...

* operand (피연산자)

  * operator가 적용되는 그런 argument

* binary , unary 연산자

  * `a+b` binary
  * `- c` unary

* 어떤 언어는 연산자를 syntactic sugar 형태로 취급한다 (좀 더 일반적으로 보이는 함수에 대해서)

  * `"+"(a,b)` = a+b (in Ada)
  * `a.operator+(b), operator+(a,b)` = a+b (in C++)

* 함수를 호출할 때, prefix,infix,postfix를 사용하는 경우가 있따

  * op : 함수, operator.. 등등 들어갈 수 있음

  * 언어마다 조금씩 달라짐

  * `op a b` : prefix

  * `a op b` : infix

  * `a b op` : postfix

  * imperative 언어에서는 infix notation을 주로 사용 (binary operator에 대해서는), unary operator는 prefix를 주요 사용

  * Lisp 언어에서는 prefix notation을 주로 사용

    * `(* (+ 1 3) 2 ) = (1+3)*2`
      `(append a b c my_list)`

    * `max (2+3) 4; ==> 5` 
      코드에서 뚜렷하게 무엇을 하는지 안다면 괄호를 넣을 필요가 없다.

    * ML , R 언어는 사용자로 하여금 새로운 infix operators를 생성할 수 있다.

    * ```R
      `%divisible%` <- function(x,y)
      {
      	if (x%%y == 0) return (TRUE)
          else return (FALSE)
      }
      > 10 %divisible% 3
      [1] FALSE
      > 10 %divisible% 2
      [1] TRUE
      > `%divisible%`(10,5)
      [1] TRUE
      ```

* Smalltalk은 infix notation을 사용

* multiword infix notation은 다른 언어에도 존재

  * `a := if b <>0 then a / b else 0;` - in Algol
  * `a = (b != 0) ? a / b : 0;` - in C (삼항 연산자)

* Forth언어에 Postscript(postfix notation)등을 사용

  * hand-held calculators 등을 포함

* 파스칼, C언어에서 Postfix 를 사용하는 경우

  * `IntPtr : ^integer; IntPtr^ := 10;` - pascal
  * `int* IntPtr; *IntPtr = 10;` - C
  * post-increment and decrement : `a++,--a` 

## Precedence and Associativity

* built-in arithmetic , logical operators

* 대부분 infix notation을 쓴다.

* 연산에 우선순위를 정해야한다

* C, c++,java,c#...etc...

  * addtional constructs, type casts, function calls, array subscripting , record field selection - 다 연산자...!

* Pascal은 너무 단순해..!

  * `if A<B and C<D then (* ouch *)`
    * A < (B and C) < D

* Associativity Rules

  * 결합 순서를 나타냄 (왼쪽으로 연산, 오른쪽으로 연산..)
  * 일반적으로는 left-to-right
  * Fortran 에서 ** 연산자
    * Right - to - Left
    * `4 ** 3 ** 2 ==> 262144` 
  * Ada 는 결합 순서가 없음, 무조건 괄호를 쳐야함
    * `(4**3)**2`
  * 일부 언어에서는 결합순서가 오른쪽에서 왼쪽으로 감
    * in C
      `a=b=a+c`
  * Haskell 언어에서는 아예 자기 만의 연산자를 만드는 것이 가능하다. (R처럼)
    * `^, infixr 8 ^` : right Associative infix operator
      * `4 ^ 3 ^ 2 -> 4 ^ (3 ^ 2)`
      * infixr, infixl 등 설정할 수 있음

* Purely functional language 

  * 프로그래밍을 구성하는 요소가 표현식이 되는 경우 ( 함수들 위주로 구현되어 있다 )
    * 거의 변수도 없다. (리턴값을 다른 함수에 인자를 넘기는 것으로 끝남)

* imperative language 에서는 메모리에 있는 어떤 변수의 값을 연속적으로 계속 바꿔나가는 것 

  * assignment (대입연산) 의 경우 가장 기초적인 내용 --> 변수의 값을 바꾸기 위해서 사용하는 것이니까..

* Side Effect

  * ```c
    int a =3;
    // 여기서 a의 값이 바뀌면 b의 값도 바뀌게 됨
    int b = a+4; 
    ```

  * subsequent computation, 최종 결과물에 영향을 미치면 side effect 라고함.

  * 변수의 값이 바뀌면 다른 일에 영향을 미치는 것.

## Assignment

* imperative 언어들은 expressions와 statements가 구별된다.
  * Expressions는 항상 값이 나와야함, Statements는 값이 안나와도 됨
  * Statements , ex) 3
  
* purely functional languages는 side Effects가 없다!
  * 결과를 어디에 저장하거나 그렇지 않으므로 Side Effect는 없다
  * side effect가 없다는 것은 표현식의 어떤 값
  * 특정 입력에 대해 특정 출력이 정해져 있음
  * 언제 실행을 시키나 특정 입력 --> 특정 결과
  * **시간**적인 이유는 아님
  
* Haskell, Miranda 언어는 Purely Functional

* ML,Lisp는 functional이 주 지만, Assignment를 사용할 수 있음

* C# Python Ruby는 거의 imperative, 하지만 함수를 first-class 취급을 해줌
  
  * 함수형 프로그래밍을 할 수 있는 특징을 가지고 있다.
  
* Reference and Value
  * l-values -- L 은 left(=location) 의미
    * L은 공간의 개념
    * [공간] = [값]
  * r-values
    * R은 Value!
  * `f(a); void f(int b);` --> b=a
  
* 모든 Expression은 l-value,r-value 라고 하기힘듬

* 모든 expression은 l-value 라고 해서 left가 공간이 되는건 아님
  * `2+3=a`
  * `a=2+3` --> a에 상수가 오면 l-value라고 할 수 없음 , 
    * `const int a =3; a= 2+3` 이건 안됨
  
* l,r value가 복잡한 expression으로 만들어질 수 있음
  * `(f(a) + 3) -> b[c] = 2;`
    * -> 는 Left에 포인터
    * f(a)의 결과값이 주소값을 반환하는 것을 추측 가능 거기에 +3 (4번째에 해당되는 그러한 배열)
    * f(a)가 포인터를 반환하고 거기에 4번쨰에 해당하는 부분이 구조체를 의미, 그 안에 b라는 멤버변수(배열임), c+1번째에 해당하는 곳이 2가 될꺼야!
  * `g(a).b[c] = 2;`
    * 구조체 자체를 의미함

* Reference Model of Variables

  * 대부분의 언어에서는 R-value를 주로 사용함, Reference Model of Variables를 사용하는 언어는 R,L을 명확하게 나타내야함
  * Algol 68, Clu, Lisp/Scheme,ML,Smalltalk
  * C는 Value model 
  * ![image-20201012142218126](./figure/reference_Model)
    * Pascal은 Value model 
      * c는 b의 값을 복사해서 넣음 (Pascal)
    * Clu는 Reference model
      * `2` 가 어딘가에 존재하고 , b는 그 `2`를 참조한다
      * c는 b가 가리키는 `2`를 참조한다
      * a는 각각 b,c가 참조하는 값을 더해서 4라는 값을 어딘가에 저장한다.
  * Reference 모델을 사용하는 언어들은 대부분 l-value는 Location을 의미함
    * R-value를 사용해야할 것 같은 상황이 만들어지면, 참조하는 값을 얻어내는 Dereference 작업이 일어나야한다!
    * reference model을 사용하는 대부분의 언어는 Dereference가 Deplicit하고 Automatic 하게 일어난다.
      * prefix exclamation point
        * `a= !b + !c` --> ML

* Reference 모델과 Value 모델의 변수의 의미는 각각 다르다

  * Reference 모델은 공간을 의미 (때떄로 R-value 처럼 사용가능하게 Dereference..)
* 어떤 같은 값을 가지고 있는 다른 오브젝트 인건지.., 다른 오브젝트인지 같은 값(같은 오브젝트를 참조하는 형태도 의미함) 을 가지고 있는지..
  
  * 변수들인데, 같은 오브젝트를 가리키는 경우
  
  * 아니면 우연히 같은 값을 갖고 있는 변수일 뿐
  
  * 이 위에 경우를 구별할 수 있어야한다.
      ![image-20201012143737664](./figure/python_Value_Reference)
  
    * c,a는 같은 값을 참조! (현재는)
        * 여기에 c = [1,5,3] ; c[1] = 7 을 하면 c는 1,7,3 / a는 1,5,3, 메모리에 다른 공간을 가리킴
        * c=a : 같은 오브젝트를 나타내는 다른 오브젝트 (같은 리스트를 가리킴)
  
    * b에 있는 a도 그 값을 참조
  * Java는 Built-in type의 Value Model을 사용
* C#의 경우 Class = reference type / struct  = value type 
  
* Boxing

  * ```java
    import java.util.ArrayList;
    ...
    ArrayList list = new ArrayList();
    ...
    list.add(new Integer(31));
    Integer m = (Integer) list.get(0);
    int newm = m.intValue();
    ```

    * 파라미터가 Object 타입을 요구했기 때문에 Object 타입으로 전달을 해야한다
    * Value 타입을 Object로 포장(wrap) --> Boxing
    * Ojbect 타입을 Value로 언박싱 --> Unboxing
      * 자동으로 해줌

  * ```java
    import java.util.ArrayList;
    
    ArrayList list = new ArrayList();
    
    list.add(31); //Value 타입을 Object로 포장함
    int newm = (Integer) list.get(0); // Object
    ```

* Orthogonality (일관성)

  * "직교" 의 의미?
  * 어떠한 기능들이 있을 때, 어떠한 조합으로 사용하더라도  조합이 당연히 타당해야하고 일관성이 유지되어야 한다.
  * Algol 68
    * 언어의 주된 설계 목표
    * 어떤 종류의 Expression이든, statement가 들어가야함
    * Expression Statement
      * `2+3; , 3;` 이런식으로 쓰는 것이 가능하다.
      * `a := if b < c then d else e;`
  * java는 orthogonality 하지 않다.(일관성이 떨어짐)
  * 다른언어에서 statement 가 필요한 경우에 expression을 넣는 것이 가능하다.
  * Expression을 Statement화 시킨 것

  ```c
  x = (y+3);
  x++;
  x=y=0;
  proc(arg1,arg2);
  y=z=(f(x)+3);
  ```

  * 이 예시는 Java에서도 지원함 (자바는 `3;` 이런 것은 안됨)

  * statement 는 expression context에 사용될 수 없음

  * C언어는 예외적으로 special expression : Selection and Seqeuncing (`-?-:-` : if else문 대체 - selection)
     `for(~~; i++,j++)` : `,` 는 Sequencing을 나타냄 일종의 Expression , 최종 결과값은 가장 오른쪽에 있는 것- 이것을 Statement로 가능

  * Algol 68, C 경우에는 Expression 안에 assignment를 사용하는 것이 가능

    * algol 68 : `:=` 비교연산자 - 수학적
    * C : `=` , `==` (비교연산자) - 효율성,실용성
      * `if ( a== b) {} , if (a=b){}` : Expression 안에 Assignment(`a==b, a=b`)를 넣는 것이 가능

  * C++는 Boolean Type을 아예 제공함

  * JAVA , C#은 Boolean Context에서 정수값을 쓰는 것은 안됨

    * `if a=b` 에서 정수 값이 나와서 Boolean Type 처럼 쓰는 것은 안됨 (둘 다 boolean type이 아닌 이상..)

  * ```c
    void func(int b);
    
    int a= 3;
    func(a);
    
    typedef struct{ int a, b} S;
    void func(S s);
    S a = { 1, 2 }; 
    func(a); //ok 초기값 지정 --> 함수에 전달 가능 
    func({1,2}); // N ok 직접적으로 함수에 전달하는 것은 안됨
    a = {3,4}; // N ok 변수에다 직접적으로 데이터를 넣는 것은 안됨 S a = {} 와 일관성이 떨어짐
    
    S f(void){
        // S s = {3,4}
        // return s 는 가능
        return {3,4}; // N ok 안댐 ㅎ
    }
    ```

  * C // Struct는 Variable Declaration (OK), Function (X) --> Orthogonality 떨어짐

  * Java // Object x 에 Class Type 저장은 가능, Built-in Function (X)

    * `object x = 3;` 은 int 가 저장되는 것이 아닌 Integer 클래스로 Boxing 해줌

  * 대부분의 언어는 배열의 인덱스를 쓸 때 정수나 정수와 유사한 simple type만 허용함

  * 대부분의 언어는 Switch case를 쓸 때 간단한 종류의 타입만 허용

  * C, C++은 배열이 Assign 되는 것은 허용되지 않는다.

    * `int a[10]; int b[10];a=b` 이건 안됨
    * Struct는 됨
      * 왜 구조체는 되고 배열은 안되 뺴엑! (일관성 X)

* Combination Assignment operators

  * ` +=, -= ` 같은 operator

    * `(a = a+1)  == (a +=1)`
    * Redundant Address calculation을 줄일 수 있다
      * 중복되는 계산

  * Side Effect를 발생시키는 경우 훨씬 더 유용하게 사용 가능

    ```c
    void update(int A[], int index_fn(int n)){
        int i,j;
        
        j = index_fn(i);
        A[j] = A[j]+1;
    }
    ```

    * index_fn()이 단순한 결과 값을 만들어 내는 것이면 
      `A[index_fn(i)] = A[index_fn(i)] + 1;` 이렇게 써도 됨

    * 하지만 함수 내에서 어떠한 영향을 미치는 경우(한번 부를때와 다시부를 때와 다를 때) 문제가 생김

      ```c
      int index_fn(int i){
          static int n = 3; 
          n ++; // 처음 나갈때에는 7 인데, 또 호출시 8이 반환되버림
          return i+n;
      }
      ```

      * 이 경우 문제가 발생함 ㅇ.<
      * 아예 `A[index_fn(i)] += 1; 이런식으로 하면 괜찮음 

  * redundant address calculation,  avoid the issue of repeated side effects;

  * elegant Syntax~ 매우 코드가 간단해짐~
    `A[--i] = b;`
    `*p++ = *q++;`

  * Prefix Forms 으로 쓰는건 +=, -= 의 Syntactic sugar다. (postfix는 완전히 다른 의미)
    `*(t=p,p+=1,t) = *(t=q, q+=1, t)`

    * t는 p를 가리킴, p를 +1 함 ==> *t
    * `,` 연산자가 순차적으로 실행시키고 마지막에 있는 expression의 값이 전체 expression의 결과값

* MultiWay Assignment - 특정 언어가 지원함

  * `a,b = c,d;` 가능 ㅎ
  * `a,b = b,a` : 이건 SWAP
  * function Return to Tuples 도 가능
    * `a,b,c = foo(d,e,f)`
  * 이 notation은 orthogonality 함
    * 여러개를 입력받으면 여러개를 출력해야지! 같은 느낌

