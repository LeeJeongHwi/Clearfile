# 프로그래밍언어론 2주차 강의

## Abstraction

* syntax 와 semantics 가 기계로부터 떨어져있는, 추상적인(abstract한) - 그러한 형태의 syntax와 semantics를 갖추기 때문에 high - level 이라고 부름 (Fortran, Algol, Lsip,C,java,python......) 
  * 사람의 말에 가까운 언어
* 목적
  * 기계 독립적(machine Independence)
  * 사람으로 하여금 프로그래밍을 이해하기 쉽게 만드는 것 (사람이 먼저다)
* name - mnemonic character string (문자열)
  * 어떤 것을 나타낼때 사용하는 문자열
* Names - Identifiers (Alphanumeric tokens) : 식별자
  * symbol - '+',':=' ....
  * variables, constants , operations , types ...
    * 변수, 상수, 함수 , 타입 등등..
    * low level concepts (like addresses) 를 사람들이 알아보기 쉽게 표현한 것
  * 코드상에 있는 어떠한 복잡한 구문(부분,조각) - 연결 시키는 작업 == binding
    * 함수에 이름을 붙여 작업하는 것, 메모리 공간에 변수라는 이름을 붙임, 클래스 등등..
    * 이름을 보고 어떠한 목적을 생각하는 것이 가능함
* 특정 컴퓨터 아키텍쳐에 대한 자세한 내용으로부터 언어의 기능을 얼마나 분리 시켰는데에 대한 것 - Abstraction
* Subroutine/function - Control abstraction
  * 복잡한 코드들을 다른이름으로 덮어서 가려주는 것 (Hide) --> 함수에다 이름을 붙이는 것
* Class - Data Abstraction
  * 데이터를 감추고 간단한 interface 제공



## Binding

* Name과 Name이 붙는 무엇인가를 연결시켜주는 것

* Binding Time - Binding이 만들어지는 시각

  * Program Writing Time
    * 변수,함수, 클래스... 등등에 이름을 붙이는 작업이 바인딩
  * Compile Time
    * for,while,if.. 특정 형태의 기계어 코드로 바꿈 => Binding
  * Link Time
    * Compile된 코드들을 붙이는 작업 => binding
    * inter-module references (import 작업..)
  * Load Time
    * 프로그램에 있는 Object(함수, 변수..)들이 기계의 주소값과 연결되어야 하는데, 그 작업도 Binding
    * virtual and physical addresses
      * virtual address 는 link-time에 결정남
  * Run Time
    * 실행 시작 ~ 실행 끝 까지 커버하는 시간
    * 변수에 대해 값을 연동시키는 것 (포인터, 주소값 등등...)
    * Program Start-up Time
    * Module Entry time
    * elaboration Time - 실제 변수에 대한 공간이 잡히고, 연동시키는 시간 ( Storage Allocation and Binding Process )
    * Procedure(== function) entry time, block entry time

* static - compile time에 일어나는 binding / dynamic - run time 에 일어나는 binding

  * interpreter - 문장이 등장할 때마다 번역을 하는 것
    * subroutine이 호출되는 각각의 시간마다 ,  다시 재 분석을 한다(변수,함수 등등..)

* Early Binding times - Greater Efficiency

* Later Binding Times - Greater Flexibility

* 일부 언어들은 컴파일 하는 것 자체가 어려움 - semantics 자체가 runtime 까지 미뤄야만 파악이 되는 문제가 있음

  * flexibility , expressiveness

  * Polymorphism(다형성)

    * 어떠한 변수를 가지고 있는데, 그 변수에 객체를 저장했는데, 저장한 실체 객체가 가지고 있지 않는 함수를 호출하지 않는 이상, 저장하는 것이 가능

    * 예시

      ```python
      a = 10 # int
      b = s # string
      # 이 경우 a에 string의 함수를 부르지 않는 이상 저장하는 것이 가능함..? 이 말인가?
      ```

    * 포괄적인 개념의 다형성..을 얘기함



## 상속 및 오버라이딩

* Early Binding
  * 컴파일시 발생하는 메소드 호출을 해결하기 위해 클래스 정보를 사용하는 프로세스
  * --> 컴파일 타임에 발생
* Late Binding
  * 런타임에 발생하는 메소드 호출을 해결하기 위해 오브젝트를 사용하는 프로세스
  * --> 런타임에 발생



## Object Lifetime and Storage Managements

* name과 object를 분리해서 생각해야한다.
* Key Events
  * 오브젝트의 생성과 제거(사라지는) 시간
  * 이름이 바인딩 되는 무언가  = object
  * 바인딩이 생성되는 시간, 사라지는 시간이 오브젝트의 생성과 제거시간이 같을 수도 있다.
  * 바인딩이 비활성화,재활성화가 가능한 경우가 있다.
* Binding's Lifetime 와 Object's Lifetime이 구별되어야 한다.
  * Binding's Lifetime
    * name-to-object의 생성과 사라지는 시간
  * Object's Lifetime
    * object의 생성과 사라지는 시간

![image-20200908124304370](./figure/passbyre)

* Pass by Reference
  * Test t(5) : Test 객체 생성
  * v는 똑같은 객체를 가리킨다 (pass by reference) -> 엘리어스를 쓴다?
  * v와 오브젝트의 binding은 func라는 함수내에서만 유용함, 함수가 끝나면 binding이 사라짐
  * 하지만 t는 main이 끝날때(프로그램이 종료될 때) 사라짐
  * v의 lifetime은 함수가 실행될때에만 있고, 변수(t) 자체는 좀 더 긴 lifetime을 가지고 있다.

![image-20200908125052565](./figure/passbyva)

* Pass by Value
  * t와 v는 다른 객체이다
  * v는 새로운 object와 binding이 이루어지는데, v라는 binding과 object의 자체는 생성시간과 종료시간(lifetime)이 같다
  * t또한 object와 lifetime이 같다.
  * reference와 lifetime이 차이가 있다.

* Name to object binding이 오브젝트 자체보다 lifetime이 긴 경우 (object는 사라졌는데 binding이 존재하는 경우)

  * 일반적으로 bug라고 봐야한다.
  * ![image-20200908125741285](./figure/bindingbug)

  * v는 넘겨받은 인자의 주소 값을 의미한다. 따라서 v 는 t의 주소값을 가지고 있고 다른 객체이다.(pass by value)
  * func 함수에서 v를 delete(해제) 하면 주소 100에 있는 객체를 해제 시키는데, 이는 t가 가리키는 객체이다.
  * 따라서 func 함수가 끝난 다음에는 t가 가리키는 Test의 객체는 사라져 있는데, t라는 변수는 남아있는 상황이다. ==> 오류

* Object가 binding보다 오래 살아 있는 경우, Garbage가 될 가능성이 높음

* Binding보다 Object가 오래 살아 있는 경우, dangling reference (= dangling pointer) 라고 부름

## Allocation

* Object Lifetime은 storage allocation과 밀접한 관련이 있다.

  * Static Objects - 프로그램 실행되는 전체과정에 대해 **절대적인 주소값** (전역변수)
    * 프로그램 시작할때 생성 ~ 프로그램 종료할때 해제
    * data 영역에 들어감 
    * Numeric and String valued contsatnt literals (ex. 14.7, "Hello world") 도 static 할당
      * 메모리 어딘가에 할당되어 있고 '변수' 처럼 사용하는 것
    * compiler는 table 들을 생성하는데 table 내에는 debugging, garbage collection,exception handling 등등... 
      실행에 필요한 것들도 Static object 이다.
    * 읽기 전용 메모리 블록을 만들어 놓고 Statically Allocated objects들을 자주 넣어 놓는다.
    
  * Stack Objects - 함수에 호출하고 반환하는 (지역변수) 것들이 스택에 해당
    * Local Variable - 함수가 호출될 때 생성되고, 반환(종료)될 때 종료(destroy) 된다.

    * Fortran 언어는 Recursion이 없다.

      * static 공간을 공유하는 것이 가능

      * named constant : 변수같은데, 상수 취급 받는 것

        * 컴파일 타임에 어떤 값을 가지도록 정해짐 (static allocation 사용 가능)

        * 컴파일 할 때 값이 정해져 있는 경우에, 컴파일 할 때 다 알려져 있어야 하므로, 정해진 함수, 산술연산자 , 이미 정해진 상수에 대한 값들만 이용해서 값을 정해야 컴파일 하는 과정에서 미리 계산하고 계산한 값을 내가 Static 하게 저장할게! < 이렇게 됨!  --> 

          > manifest constants, compile-time constants

        * 함수 내에서 만들어진 상수인 것 처럼 쓰인다 하더라도 그 상수를 매번 만드는 것이 아니라 똑같은 메모리 공간을 공유하게 됨

      * C,Java 등에서는 상수라는 개념이 변수인데 값을 바꿀 수 없는 변수를 의미함 (static allocation 불가능)  == Elaboration Constants

        * 컴파일 타임에 생성되지 않기 때문!

      * C#은 const, readonly 로 나누어서 지정 가능

        * readonly : elaboration constant
        * const : compile-time constant

      * ![image-20200910125506409](./figure/stackallocation)

        * function 내에 const는 readonly Variable 이다. --> Stack Allocation

    * stack-based allocation

      * Recursion 이 가능함
      * subroutine에 각각에 호출 될때마다 생기는 영역 , activation record(frame)가 만들어짐
        * activation record : subroutine에 사용하는 매개변수, return 값 , 변수 등등 담아 놓는 공간 (함수가 호출될 때 마다 생성)
      * Bookkeeping information : subroutine에 return address, stack frame에 대한 reference(caller), registers
        * registers : 함수 호출할 때 레지스터들을 다 가져와서 메모리에 저장
      * 다음 함수로 전달되는 argument 들은 Frame 가장 위쪽에  위치함
        * callee (호출되는 쪽) 이 쉽게 접근할 수 있게 하기 위함

    ![image-20200910130503216](./figure/stackbased)

    * Calling Sequence : stack frame을 관리함 , subroutine의 prologue, epilogue ..
      * caller에 의해 실행되는 코드, 함수 호출하기 바로 직전, 직후 실행되는 코드 --> return 값 ,arg 처리
      * prologue : called subroutine에 시작 부분에 실행되는 코드
      * epilogue : called subroutine에  끝 부분에 마무리 짓는 코드
    * Stack frame이 불릴지 안불릴지 예측이 불가하기 때문에, 기준점을 잡아놓고 offset을 만들어놓음
      * 프레임 내에 상대적인 위치로 결정함
        * 그 위치가 어디로 가더라도 주소를 가지고 계산을 할 수 있기 때문
      * frame pointer(stack pointer) 의 시작 위치를 가지고 특정 레지스터에 저장, 상대적인 위치 값으로 변수를 access 함 - esp
      * 지역변수, temporaries, booking information 은 음수 offsets
      * 인자들, 리턴값은 양수 offsets (caller's frame에 있기 때문)
    * static allocation 보다는 stack allocation 이 적은 양의 메모리를 사용할 가능성이 있다.

  * Heap Objects - 동적할당 : new,malloc , runtime에 할당해주는 object들 , 동적할당을 할 수 있는 메모리 공간

    * 언제가 될지 모르지만, subblocks가 할당되었다가 해제되었다가 .. 하는 작업이 일어나는 공간이 heap

    * 힙 공간 관리 : speed and space의 낭비를 관리

      * Fragmentation (메모리 공간이 쪼개져서 사용이 안되는 경우)

        > internal fragmentation (내부 단편화)
        >
        > external fragmentation (외부 단편화)
        >
        > https://jhnyang.tistory.com/264

    * storage - management algorithms

      * First - Fit (O(1))
        * 할당 가능한 메모리 크기 중 제일 첫번째
      * Best - Fit (O(n))
        * 할당 가능한 메모리 크기들을 scan 후 가장 작은 크기
      * Worst - Fit (O(n))
        * 할당 가능한 메모리 크기들을 scan 후 가장 큰 크기

    * Buddy System , Fibonacci Heaps

      * 메모리 할당 요청들 중에 비어있는 메모리 공간을 round up 해서 next standard size를 할당 -> internal fragmentation은 거의 무조건 생김

    * External Fragmentation은 오래 쓰면 쓸 수록 발생할 수 밖에 없음

      * Heap 을 Compact 시킴 (메모리조각모음) --> 할당된 메모리들을 한 곳에 몰아넣고 비어있는 공간 확보
        * 하지만 이 것도 문제가 좀 있음

## Garbage Collection

* Heap based object을 allocation 하는 경우는 특정 작업에만 생성됨
  * 객체 생성
  * 리스트에 추가
  * 짧은 문자열을 쓰던 공간에 긴 문자열을 할당하려 할 때
* Deallocation을 C,C++,Rust 내에서는 직접 요청해야함
* Garbage collection machanism - garbage를 찾아내고, reclaim(회수)하는 작업
  * Java , Python,C#은 자동으로 deallocate
    * Garbage가 됐을 때 자동으로 삭제함
* Explicit Deallocation
  * 장점
    * 구현이 간단함 (언어 제작자 입장)
    * 실행속도가 빠름 (시스템언어)
  * 단점
    * 에러를 좀 많이 일으킴 (pointer error...)
    * dangling reference
    * object가 deallocated가 안된 경우에 memory leak(메모리 낭비)가 생김 --> allocate 시 문제가 생김
* Garbage Collection
  * 장점
    * 자동으로 deallocation (error 문제 X)
    * 런타임 오버헤드를 줄여줌 (알고리즘이 발전하고 있음!)
  * 단점
    * 구현하는데 어려움 (언어 제작자 입장)
    * garbage collector가 실제로 시간을 좀 많이 쓸 수 밖에 없다 (실행을 멈춰야 garbage인것을 찾아내기 때문에)
  * 사람이 예전보다는 편하게 코딩함 (automatic collection을 만드는 제작자 입장에서는..조금 귀찮)