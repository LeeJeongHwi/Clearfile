# 3주차 강의



## Object Lifetime and Storage Managements (2주차 강의 복습)

* Object : 이름과 연결되어 있는 어떠한 것

* binding : 이름과 object를 연결시키는 것을 binding

* Binding's Lifetime : 이름과 object를 연결시켜주는 과정의 시작과 끝을 나타냄 (바인딩이 살아있는 시간)

* Object's Lifetime : Object가 만들어지고 사라지는 시간

  * ```fc++
    void f(){
    	int a;
    }
    ```

    * a라는 이름을 만들어내고, 변수의 공간을 만들어줌 (stack allocation)

    * stack에 4byte 짜리 메모리 공간(object)을 만들어주고 a라는 이름을 연결시켜준다 - Binding

    * binding과 object의 생성시기가 같고, 사라지는 시간도 같다. (binding lifetime == object lifetime)

  * ```fortran
    f(){
    	int n;
    }
    ```

    * Fortran의 경우 static allocation을 하기 때문에 프로그램 시작과 동시에 n이라는 공간(object)이 data 영역에 할당되어 object lifetime은 
      프로그램 시작과 끝이지만 binding lifetime은 f()라는 함수를 부를 때 binding이 되므로 binding의 lifetime과 object lifetime은 동일하지 않다
    * C++ 에서도 `static int a;` 로 선언을 하게되면 stack 영역이 아닌 data영역에 할당된다. (Binding lifetime != object lifetime)

  * ```c++
    class Test{
        Test(int v) {value v= v;}
        int value;
        int getValue() {return value;}
    }
    void func(Test& v) { //pass by reference , v lifetime Creation(binding)
        int c = v.getValue(); // v.getValue() == t.getValue()
        printf("value=%d\n",c);
        // v lifetime destruction(binding)
    }
    int main(){
        Test t(5); // Stack allocation , t lifetime creation(binding, object)
        func(t);
        printf("value=%d\n",t.getValue());
        // t lifetime destruction(binding, object)
    }
    ```

    * t라는 변수의 객체가 func(Test& v)의 인자로 전달되는데,  똑같은 메모리 공간에 v라는 이름을 붙인다.
    * t는 프로그램 시작~끝의 lifetime을 갖는다.(object,binding lifetime 둘 다)
    * v의 binding lifetime은 함수의 시작~끝의 lifetime을 갖지만, v의 object(= t)는 더 긴 lifetime을 갖는 것 이다.

  * ```c++
    class Test{
        Test(int v) {value v= v;}
        int value;
        int getValue() {return value;}
    }
    void func(Test v) { //pass by Value , v lifetime Creation(binding,object)
        int c = v.getValue(); // v.getValue() != t.getValue()
        printf("value=%d\n",c);
        // v lifetime destruction(binding,object)
    }
    int main(){
        Test t(5); // Stack allocation , t lifetime creation(binding, object)
        func(t);
        printf("value=%d\n",t.getValue());
        // t lifetime destruction(binding, object)
    }
    ```

    * v라는 공간을 새로 메모리에 할당한다. 즉 func 시작과 동시에 v 라는 object 가 생성되고 binding이 된다. (Object lifetime == Binding lifetime)
    * t와 v는 별개가 된다!

  * ```c++
    void func(Test* v){ //pass by value
        int c = v-> getValue(); // Test.getValue()
        printf("value =%d\n",c);
        delete v; // Test의 객체를 Free시킴 , t와의 binding은 아직 존재함
    }
    int main(){
        Test* t = new Test(5); // Test는 heap에 object 할당 , t는 stack에 할당(주소(=Test의 시작공간)를 담는 공간)
        func(t); 
        printf("value=%d\n",t->getValue()); // Object Lifetime < Binding Lifetime이 되어버림(아무것도 없는 공간에 binding)
    }
    ```

    * func에서 Test 객체를 Free 시키는 바람에 t는 아무것도 없는 공간에 binding이 되어있는 상황이 발생 => **dangling Pointer(dangling reference)**
    * object는 사라졌는데 binding이 남아있는 경우 , 일반적으로 버그!

  * ```c++
    Test* t = new Test();
    t = new Test2();
    ```

    * ln 1: heap 에 Test() 객체를 생성하고, t와 binding이 된 상태
    * ln 2: heap 에 Test2() 객체를 생성하고, t와 binding 되면서 기존에 있던 Test()와의 객체와 binding이 해제되서 Object lifetime이 더 길어지게 된 경우
      --> **garbage**



## Scope Rules

* Scope of a binding : binding이 활성화 되어있는 프로그램의 textual region(Text 영역)
* Statically Scoped (compile time) 
* Dynamically Scoped (Run time)



### Scope

* Binding이 바뀌지 않는, 프로그램의 최대 Region(큰 영역)을 의미함
* 아무것도 Destroy 되지 않는 최대 영역
* 사라지지 않는, 다른 scope로 바뀌지 않는 범위 내에서 가장 큰 영역



### Referencing Environment

* 프로그램 실행되는 순간을 뽑았을 때, 사용할 수 있는 binding(변수, 함수...) 들만 쫙 뽑아 놓은..것
* static, dynamic scope rules 에 따라 결정된다.



#### In C

* subroutine(함수 등등) 에 진입할 때 새로운 scope가 실행된다.

  * local objects(지역 변수)에 해당하는 binding을 생성하고 global objects(전역 변수)에 해당되는 binding을 deactivate 한다.
    --> 같은 이름을 가진 local object에 대해서 global object를 hidden(Deactivate) 시킨다.

* subroutine이 끝났을 때

  * local object binding이 사라지고, global object(같은 이름의 local object에 한해서) 를 다시 Reactivate 시킨다.

* ```c
  int a;
  void f(){
      int a; // 이 경우 전역변수 a는 hidden 된다.
      a = 3; // 지역변수 a를 의미
  }
  ```

### Static Scoping

* Compile time에 결정되므로, 코드를 확인 했을 때 binding을 식별 가능하다.

* 실행 흐름을 전혀 고려하지 않아도 된다. (Text 만 확인하면 됨!)

* 이름이 주어졌을 때, current binding을 프로그램 상에 가장 가까이 둘러싸고 있는 block안의 같은 이름을 가진 Declaration을 살펴보고 matching 시킨다.

* Basic 언어
  * Scope가 한 개 밖에 없었음
  * declaration (변수 함수의 이름이 scope 영역에 보이게 만들어 주는 것 - 선언) 의 개념이 없었음
  * 변수의 타입이 결정되어 있지 않는다.

* pre-Frotran 90
  * 전역 변수와 지역 변수의 개념이 따로 있었다.
  * 지역 변수의 scope은 subroutine에 한정 되어 있다.
  * 지역 변수는 함수 밖에서는 절대 보이지 않는다.
  * type 지정이 필수는 아니다
  * 그 뒤 이후에 정해진 Frotran 언어는 변수는 무조건 declaration 으로 해야한다. 안그러면 Compile-Time Error를 일으킴 (Type-Script 방식)
    * Type-Script는 유지보수가 쉬워짐
  
* 재귀호출을 할 때 지역변수들은 새로만들어 지는 것!

  * 함수가 종료되면 지역변수가 사라지고, 또 호출되면 새로 만들어짐!

* `save` : 다시 실행을 할 때 기록이 남아있도록 해주는 것! (fortran) , `static` : C언어

  * 함수가 다시 실행되더라도 값을 **유지**하는 거
  * 전역의 위치에 만들어 놓는 것
  * 함수가 실행되지 않을 때에는 binding은 사라짐!

  ```c++
  void label_name(char *s){
      static short int n;
      sprintf(s,"L%d\0",++n);
  }
  >> L1
     L2
     ..
  ```

### Nested Subroutine

* 함수 내에 지역함수를 쓸 수 있도록 하는 것! (Python, Scheme,Swift.....)

  * ```python
    def a():
        print("Outer Function")
        def b():
            print('inner function')
        return b
    ```

* Closest Nested Scope rule

  * declare : 이름을 스코프에 알림

  * decalred 된 변수,함수는 그 함수안에서**만** 변수의 이름이 유효하다

  *  ```python
    def a():
        i = 10 # (1)
        def b():
            i+=1 # (1)을 가리킴 
            print(i)
        return b
    >> a()
    11
     ```

    * i는 a() 내에서만 유효하다
    * b() 에서의 i는 전역변수같은 **느낌**이다

  * ```python
    def a():
        i = 10 # (1)
        def b():
            i = 12 # (2)
            print(i)
        print(i)
        return b
    >> a()
    10
    12
    ```

    * 여기서 b()내에 있는 i는 변수가 **다시** 선언되는 것이다.
    * 즉 a()의 i는 감춰진다(binding이 Deactivate)

  * 어떤 object 와 연결되어 있는지 궁금하면, **가장 가까운 곳에 연결된 scope**부터 찾는다

    * 해당 scope 영역에 변수가 있으면 binding이 active 된다.
    * 없으면 바깥쪽 scope 영역을 탐색한다.

* built-in 함수들은 전역에 안보이는 영역이 있고, 그 내에 선언이 되어있다.

* Scope Resolution Operator

  * ```c++
    // Ada 언어
    My_proc.X (subroutine 안에 있는 X 변수)
    // C++
    ::X (전역에 해당하는 X 변수를 의미)
    namespace name (함수이름)
    ```

* Access to Nonlocal Object

  * 컴파일러는 runtime 상에 현재 실행중인 subroutine의 frame(stack frame)을 가리키도록 할 수 있다.
  * 이 frame pointer register를 base로 displacement(register plus offset) addressing(offset 기준으로 계산)
    current 함수를 access 한다..!

* 함수 밖에 있는 애들은?

  * frame register는 모르는 영역임

  * Static Link - parent Frame에 가지고 있을 것이다.

    * ```c++
      void P1(){
          void P2(){
              void p3(){
              }
          }
          void p4(){
          }
      }
      ```

      * P2는 P1의 static link 를 가지고 있고 p3는 P2를.. P4는 P1을.. 가지고있다
      * null static Link를 가질 때 까지 (가장 마지막 까지) static link를 타고 들어간다.

  