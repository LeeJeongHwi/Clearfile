# 3주차 강의



## Object Lifetime and Storage Managements (2주차 강의 복습)

* Object : 이름과 연결되어 있는 어떠한 것

* binding : 이름과 object를 연결시키는 것을 binding

* Binding's Lifetime : 이름과 object를 연결시켜주는 과정의 시작과 끝을 나타냄 (바인딩이 살아있는 시간)

* Object's Lifetime : Object가 만들어지고 사라지는 시간

  * ```fc++
    void f(){
    	int a;
    }
    ```

    * a라는 이름을 만들어내고, 변수의 공간을 만들어줌 (stack allocation)

    * stack에 4byte 짜리 메모리 공간(object)을 만들어주고 a라는 이름을 연결시켜준다 - Binding

    * binding과 object의 생성시기가 같고, 사라지는 시간도 같다. (binding lifetime == object lifetime)

  * ```fortran
    f(){
    	int n;
    }
    ```

    * Fortran의 경우 static allocation을 하기 때문에 프로그램 시작과 동시에 n이라는 공간(object)이 data 영역에 할당되어 object lifetime은 
      프로그램 시작과 끝이지만 binding lifetime은 f()라는 함수를 부를 때 binding이 되므로 binding의 lifetime과 object lifetime은 동일하지 않다
    * C++ 에서도 `static int a;` 로 선언을 하게되면 stack 영역이 아닌 data영역에 할당된다. (Binding lifetime != object lifetime)

  * ```c++
    class Test{
        Test(int v) {value v= v;}
        int value;
        int getValue() {return value;}
    }
    void func(Test& v) { //pass by reference , v lifetime Creation(binding)
        int c = v.getValue(); // v.getValue() == t.getValue()
        printf("value=%d\n",c);
        // v lifetime destruction(binding)
    }
    int main(){
        Test t(5); // Stack allocation , t lifetime creation(binding, object)
        func(t);
        printf("value=%d\n",t.getValue());
        // t lifetime destruction(binding, object)
    }
    ```

    * t라는 변수의 객체가 func(Test& v)의 인자로 전달되는데,  똑같은 메모리 공간에 v라는 이름을 붙인다.
    * t는 프로그램 시작~끝의 lifetime을 갖는다.(object,binding lifetime 둘 다)
    * v의 binding lifetime은 함수의 시작~끝의 lifetime을 갖지만, v의 object(= t)는 더 긴 lifetime을 갖는 것 이다.

  * ```c++
    class Test{
        Test(int v) {value v= v;}
        int value;
        int getValue() {return value;}
    }
    void func(Test v) { //pass by Value , v lifetime Creation(binding,object)
        int c = v.getValue(); // v.getValue() != t.getValue()
        printf("value=%d\n",c);
        // v lifetime destruction(binding,object)
    }
    int main(){
        Test t(5); // Stack allocation , t lifetime creation(binding, object)
        func(t);
        printf("value=%d\n",t.getValue());
        // t lifetime destruction(binding, object)
    }
    ```

    * v라는 공간을 새로 메모리에 할당한다. 즉 func 시작과 동시에 v 라는 object 가 생성되고 binding이 된다. (Object lifetime == Binding lifetime)
    * t와 v는 별개가 된다!

  * ```c++
    void func(Test* v){ //pass by value
        int c = v-> getValue(); // Test.getValue()
        printf("value =%d\n",c);
        delete v; // Test의 객체를 Free시킴 , t와의 binding은 아직 존재함
    }
    int main(){
        Test* t = new Test(5); // Test는 heap에 object 할당 , t는 stack에 할당(주소(=Test의 시작공간)를 담는 공간)
        func(t); 
        printf("value=%d\n",t->getValue()); // Object Lifetime < Binding Lifetime이 되어버림(아무것도 없는 공간에 binding)
    }
    ```

    * func에서 Test 객체를 Free 시키는 바람에 t는 아무것도 없는 공간에 binding이 되어있는 상황이 발생 => **dangling Pointer(dangling reference)**
    * object는 사라졌는데 binding이 남아있는 경우 , 일반적으로 버그!

  * ```c++
    Test* t = new Test();
    t = new Test2();
    ```

    * ln 1: heap 에 Test() 객체를 생성하고, t와 binding이 된 상태
    * ln 2: heap 에 Test2() 객체를 생성하고, t와 binding 되면서 기존에 있던 Test()와의 객체와 binding이 해제되서 Object lifetime이 더 길어지게 된 경우
      --> **garbage**



## Scope Rules

* Scope of a binding : binding이 활성화 되어있는 프로그램의 textual region(Text 영역)
* Statically Scoped (compile time) 
* Dynamically Scoped (Run time)



### Scope

* Binding이 바뀌지 않는, 프로그램의 최대 Region(큰 영역)을 의미함
* 아무것도 Destroy 되지 않는 최대 영역
* 사라지지 않는, 다른 scope로 바뀌지 않는 범위 내에서 가장 큰 영역



### Referencing Environment

* 프로그램 실행되는 순간을 뽑았을 때, 사용할 수 있는 binding(변수, 함수...) 들만 쫙 뽑아 놓은..것
* static, dynamic scope rules 에 따라 결정된다.



#### In C

* subroutine(함수 등등) 에 진입할 때 새로운 scope가 실행된다.

  * local objects(지역 변수)에 해당하는 binding을 생성하고 global objects(전역 변수)에 해당되는 binding을 deactivate 한다.
    --> 같은 이름을 가진 local object에 대해서 global object를 hidden(Deactivate) 시킨다.

* subroutine이 끝났을 때

  * local object binding이 사라지고, global object(같은 이름의 local object에 한해서) 를 다시 Reactivate 시킨다.

* ```c
  int a;
  void f(){
      int a; // 이 경우 전역변수 a는 hidden 된다.
      a = 3; // 지역변수 a를 의미
  }
  ```

### Static Scoping

* Compile time에 결정되므로, 코드를 확인 했을 때 binding을 식별 가능하다.
* 실행 흐름을 전혀 고려하지 않아도 된다. (Text 만 확인하면 됨!)
* 이름이 주어졌을 때, current binding을 프로그램 상에 가장 가까이 둘러싸고 있는 block안의 같은 이름을 가진 Declaration을 살펴보고 matching 시킨다.
* Basic 언어
  * Scope가 한 개 밖에 없었음
  * declaration (변수 함수의 이름이 scope 영역에 보이게 만들어 주는 것 - 선언) 의 개념이 없었음
  * 변수의 타입이 결정되어 있지 않는다.

* pre-Frotran 90
  * 전역 변수와 지역 변수의 개념이 따로 있었다.
  * 지역 변수의 scope은 subroutine에 한정 되어 있다.
  * 지역 변수는 함수 밖에서는 절대 보이지 않는다.
  * type 지정이 필수는 아니다
  * 그 뒤 이후에 정해진 Frotran 언어는 변수는 무조건 declaration 으로 해야한다. 안그러면 Compile-Time Error를 일으킴 (Type-Script 방식)
    * Type-Script는 유지보수가 쉬워짐