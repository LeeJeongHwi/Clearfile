# 3주차 강의



## Object Lifetime and Storage Managements (2주차 강의 복습)

* Object : 이름과 연결되어 있는 어떠한 것

* binding : 이름과 object를 연결시키는 것을 binding

* Binding's Lifetime : 이름과 object를 연결시켜주는 과정의 시작과 끝을 나타냄 (바인딩이 살아있는 시간)

* Object's Lifetime : Object가 만들어지고 사라지는 시간

  * ```fc++
    void f(){
    	int a;
    }
    ```

    * a라는 이름을 만들어내고, 변수의 공간을 만들어줌 (stack allocation)

    * stack에 4byte 짜리 메모리 공간(object)을 만들어주고 a라는 이름을 연결시켜준다 - Binding

    * binding과 object의 생성시기가 같고, 사라지는 시간도 같다. (binding lifetime == object lifetime)

  * ```fortran
    f(){
    	int n;
    }
    ```

    * Fortran의 경우 static allocation을 하기 때문에 프로그램 시작과 동시에 n이라는 공간(object)이 data 영역에 할당되어 object lifetime은 
      프로그램 시작과 끝이지만 binding lifetime은 f()라는 함수를 부를 때 binding이 되므로 binding의 lifetime과 object lifetime은 동일하지 않다
    * C++ 에서도 `static int a;` 로 선언을 하게되면 stack 영역이 아닌 data영역에 할당된다. (Binding lifetime != object lifetime)

  * ```c++
    class Test{
        Test(int v) {value v= v;}
        int value;
        int getValue() {return value;}
    }
    void func(Test& v) { //pass by reference , v lifetime Creation(binding)
        int c = v.getValue(); // v.getValue() == t.getValue()
        printf("value=%d\n",c);
        // v lifetime destruction(binding)
    }
    int main(){
        Test t(5); // Stack allocation , t lifetime creation(binding, object)
        func(t);
        printf("value=%d\n",t.getValue());
        // t lifetime destruction(binding, object)
    }
    ```

    * t라는 변수의 객체가 func(Test& v)의 인자로 전달되는데,  똑같은 메모리 공간에 v라는 이름을 붙인다.
    * t는 프로그램 시작~끝의 lifetime을 갖는다.(object,binding lifetime 둘 다)
    * v의 binding lifetime은 함수의 시작~끝의 lifetime을 갖지만, v의 object(= t)는 더 긴 lifetime을 갖는 것 이다.

  * ```c++
    class Test{
        Test(int v) {value v= v;}
        int value;
        int getValue() {return value;}
    }
    void func(Test v) { //pass by Value , v lifetime Creation(binding,object)
        int c = v.getValue(); // v.getValue() != t.getValue()
        printf("value=%d\n",c);
        // v lifetime destruction(binding,object)
    }
    int main(){
        Test t(5); // Stack allocation , t lifetime creation(binding, object)
        func(t);
        printf("value=%d\n",t.getValue());
        // t lifetime destruction(binding, object)
    }
    ```

    * v라는 공간을 새로 메모리에 할당한다. 즉 func 시작과 동시에 v 라는 object 가 생성되고 binding이 된다. (Object lifetime == Binding lifetime)
    * t와 v는 별개가 된다!

  * ```c++
    void func(Test* v){ //pass by value
        int c = v-> getValue(); // Test.getValue()
        printf("value =%d\n",c);
        delete v; // Test의 객체를 Free시킴 , t와의 binding은 아직 존재함
    }
    int main(){
        Test* t = new Test(5); // Test는 heap에 object 할당 , t는 stack에 할당(주소(=Test의 시작공간)를 담는 공간)
        func(t); 
        printf("value=%d\n",t->getValue()); // Object Lifetime < Binding Lifetime이 되어버림(아무것도 없는 공간에 binding)
    }
    ```

    * func에서 Test 객체를 Free 시키는 바람에 t는 아무것도 없는 공간에 binding이 되어있는 상황이 발생 => **dangling Pointer(dangling reference)**
    * object는 사라졌는데 binding이 남아있는 경우 , 일반적으로 버그!

  * ```c++
    Test* t = new Test();
    t = new Test2();
    ```

    * ln 1: heap 에 Test() 객체를 생성하고, t와 binding이 된 상태
    * ln 2: heap 에 Test2() 객체를 생성하고, t와 binding 되면서 기존에 있던 Test()와의 객체와 binding이 해제되서 Object lifetime이 더 길어지게 된 경우
      --> **garbage**



## Scope Rules

* Scope of a binding : binding이 활성화 되어있는 프로그램의 textual region(Text 영역)
* Statically Scoped (compile time) 
* Dynamically Scoped (Run time)



### Scope

* Binding이 바뀌지 않는, 프로그램의 최대 Region(큰 영역)을 의미함
* 아무것도 Destroy 되지 않는 최대 영역
* 사라지지 않는, 다른 scope로 바뀌지 않는 범위 내에서 가장 큰 영역



### Referencing Environment

* 프로그램 실행되는 순간을 뽑았을 때, 사용할 수 있는 binding(변수, 함수...) 들만 쫙 뽑아 놓은..것
* static, dynamic scope rules 에 따라 결정된다.



#### In C

* subroutine(함수 등등) 에 진입할 때 새로운 scope가 실행된다.

  * local objects(지역 변수)에 해당하는 binding을 생성하고 global objects(전역 변수)에 해당되는 binding을 deactivate 한다.
    --> 같은 이름을 가진 local object에 대해서 global object를 hidden(Deactivate) 시킨다.

* subroutine이 끝났을 때

  * local object binding이 사라지고, global object(같은 이름의 local object에 한해서) 를 다시 Reactivate 시킨다.

* ```c
  int a;
  void f(){
      int a; // 이 경우 전역변수 a는 hidden 된다.
      a = 3; // 지역변수 a를 의미
  }
  ```

### Static Scoping

* Compile time에 결정되므로, 코드를 확인 했을 때 binding을 식별 가능하다.

* 실행 흐름을 전혀 고려하지 않아도 된다. (Text 만 확인하면 됨!)

* 이름이 주어졌을 때, current binding을 프로그램 상에 가장 가까이 둘러싸고 있는 block안의 같은 이름을 가진 Declaration을 살펴보고 matching 시킨다.

* Basic 언어
  * Scope가 한 개 밖에 없었음
  * declaration (변수 함수의 이름이 scope 영역에 보이게 만들어 주는 것 - 선언) 의 개념이 없었음
  * 변수의 타입이 결정되어 있지 않는다.

* pre-Frotran 90
  * 전역 변수와 지역 변수의 개념이 따로 있었다.
  * 지역 변수의 scope은 subroutine에 한정 되어 있다.
  * 지역 변수는 함수 밖에서는 절대 보이지 않는다.
  * type 지정이 필수는 아니다
  * 그 뒤 이후에 정해진 Frotran 언어는 변수는 무조건 declaration 으로 해야한다. 안그러면 Compile-Time Error를 일으킴 (Type-Script 방식)
    * Type-Script는 유지보수가 쉬워짐
  
* 재귀호출을 할 때 지역변수들은 새로만들어 지는 것!

  * 함수가 종료되면 지역변수가 사라지고, 또 호출되면 새로 만들어짐!

* `save` : 다시 실행을 할 때 기록이 남아있도록 해주는 것! (fortran) , `static` : C언어

  * 함수가 다시 실행되더라도 값을 **유지**하는 거
  * 전역의 위치에 만들어 놓는 것
  * 함수가 실행되지 않을 때에는 binding은 사라짐!

  ```c++
  void label_name(char *s){
      static short int n;
      sprintf(s,"L%d\0",++n);
  }
  >> L1
     L2
     ..
  ```

### Nested Subroutine

* 함수 내에 지역함수를 쓸 수 있도록 하는 것! (Python, Scheme,Swift.....)

  * ```python
    def a():
        print("Outer Function")
        def b():
            print('inner function')
        return b
    ```

* Closest Nested Scope rule

  * declare : 이름을 스코프에 알림

  * decalred 된 변수,함수는 그 함수안에서**만** 변수의 이름이 유효하다

  *  ```python
    def a():
        i = 10 # (1)
        def b():
            i+=1 # (1)을 가리킴 
            print(i)
        return b
    >> a()
    11
    ```

    * i는 a() 내에서만 유효하다
    * b() 에서의 i는 전역변수같은 **느낌**이다

  * ```python
    def a():
        i = 10 # (1)
        def b():
            i = 12 # (2)
            print(i)
        print(i)
        return b
    >> a()
    10
    12
    ```

    * 여기서 b()내에 있는 i는 변수가 **다시** 선언되는 것이다.
    * 즉 a()의 i는 감춰진다(binding이 Deactivate)

  * 어떤 object 와 연결되어 있는지 궁금하면, **가장 가까운 곳에 연결된 scope**부터 찾는다

    * 해당 scope 영역에 변수가 있으면 binding이 active 된다.
    * 없으면 바깥쪽 scope 영역을 탐색한다.

* built-in 함수들은 전역에 안보이는 영역이 있고, 그 내에 선언이 되어있다.

* Scope Resolution Operator

  * ```c++
    // Ada 언어
    My_proc.X (subroutine 안에 있는 X 변수)
    // C++
    ::X (전역에 해당하는 X 변수를 의미)
    namespace name (함수이름)
    ```

* Access to Nonlocal Object

  * 컴파일러는 runtime 상에 현재 실행중인 subroutine의 frame(stack frame)을 가리키도록 할 수 있다.
  * 이 frame pointer register를 base로 displacement(register plus offset) addressing(offset 기준으로 계산)
    current 함수를 access 한다..!

* 함수 밖에 있는 애들은?

  * frame register는 모르는 영역임

  * Static Link - parent Frame에 가지고 있을 것이다.

    * ```c++
      void P1(){
          void P2(){
              void p3(){
              }
          }
          void p4(){
          }
      }
      ```

      * P2는 P1의 static link 를 가지고 있고 p3는 P2를.. P4는 P1을.. 가지고있다
      * null static Link를 가질 때 까지 (가장 마지막 까지) static link를 타고 들어간다.


### Declaration Order

* 변수들이 모두들 선언이 되어있어야 사용이 가능하다. (Ealry Language)

* Pascal

  * 사용되기 전에 선언이 되어야한다.

  * recursive types(mutual Recursion 인 경우..) 그리고 subroutines 경우에 만들어지지 않은 함수를 선언할 때 문제가 생김

    ```c++
    /*-- c++ --*/
    void g(); // Prototype
    void f(){
        g(); 
    }
    void g(){
        f();
    }
    //Mutual Recursion
    ```

    * 선언되지 않은 함수를 사용하는 것이기 때문에 문제가 생김 --> **Prototype**을 사용!

  * Pascal은 forward 를 사용 

  * 함수 안에 변수가 만들어졌으면 함수 안에 전체가 Scope 영역

  * 변수가 만들어졌는데, 뒤에 만들어졌다하더라도 그 변수의 scope 영역은 함수 전체 영역(프로그램 전체 영역) 그리고 선언 후 사용 rule 과 충돌..

    ```pascal
    const N = 10; // (1)
    procedure foo;
    const
    	M = N;
    	
    	N = 20; // (2)
    ```

    * 이 경우 오류가 발생한다.
      * scope 영역이 foo 영역 전체 이므로, M=N 에서 Scope 영역 내에 있는 N을 가리키게 됨
      * 하지만 N은 선언되기 전에 사용되었으므로 오류가 발생함

  * ```pascal
    const N = 10;
    procedure foo;
    const
        M=N;
    var
        A : array[1..m] of integer
        N : real;
    ```

    * 여기서 foo 영역에서 N은 미리 선언되지 않았으므로 M=N은 오류
    * N은 상수가 아니고 변수 이므로 오류

* 변수 선언된 부분이 유효한지 아닌지 확인하려면, Pascal 컴파일러는 Scope  영역에 있는 모든 것들을 다 확인해야함
  그리고 그 이름이 Hidden인지 아닌지 확인 해야함 --> 복잡해짐...

* Pascal 후기작은 전체 영역을 scope로 잡는 것이 아니라, Declaration 만들어진 순간 부터 그 블록의 끝, 거기까지가 Declaration의 영역이 됨

  ```pascal
  const N = 10; // (1)
  procedure foo;
  const
   m = n;
  var
   a : []
   N : real; // (2)
  ```

  * 이 경우 (2)는 선언된 이후 부터 사용가능하고 (1)도 마찬가지다. 즉 이상태에서 m은 10이 되는 것이다.

* C++, JAVA 는 Defind - before - use Rule을 조금 풀어줌

  * ```java
    class Test{
        void pprint(){
            print() // 딱히 문제 되지 않음
        }
     	void print(){
            System.out.println("value = " + value);
        }
        int value = 5; // 딱히 문제되지는 않음
    }
    ```

    * 이 경우 class 영역 안에서는 선언되었다면 Class 내에선 다 사용 가능

  * ```java
    class ChildClass extends ParentClass{
        ...
    }
    class ParentClass{
        ...
    }
    ```

    * 이 경우에도 문제되지 않는다.

  * C#은 Pascal의 Whole-block-scope Rule을 사용

  * Python은 변수가 선언되어 있는 전체 영역을 커버하는 Whole-block-scope rule을 사용

    * ```python
      def T():
      	x = 3 # (1)
      	print(x)
      	def S():
      		print(x)
      		x=5 # (2)
      		print(x)
      	S()
      	print(x)
      T()
      >>
      3
      Traceback (most recent call last):
        File "test.py", line 10, in <module>
          T()
        File "test.py", line 8, in T
          S()
        File "test.py", line 5, in S
          print(x)
      UnboundLocalError: local variable 'x' referenced before assignment
      ```

      * 여기서 S()의 첫 print는 x가 선언이 되기전에 사용되었다. 왜냐면 scope영역 (S() 영역) 내에 x가 존재하기 때문
      * 첫 print를 주석처리하면 옳바르게 실행됨
      * Python은 `global` 을 사용해서 전역변수를 부를 수 있다.
      * 정리하자면 S() 내에 x가 불려지기 때문에 (1)의 x는 가려져서 S()의 첫 print는 오류를 발생하는 것이다.
      * read-only의 경우 오류 없이 수행가능, 즉 (2)가 없는 경우!

