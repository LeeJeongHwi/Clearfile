# 4주차 강의

## Declaration and Definitions

```c
/* extern 이 빠져있다고 생각해도 됨 */ void g();  //Declaration
void f(){  //Definition
    g();
}
void g(){
    f();
}
```

* Declaration 은 어떤 입력, 반환값, 이름만 미리 알려주는 것
* Definition 은 실제 구현 정보

* f()는 선언과 정의를 동시에 함

```c
struct manager; // delcaration
struct employee{ // definition
    struct manager* boss;
    struct employee* next_employee;
}
struct manager{
    struct employee* first_employee
}
```

* 이 경우 manager가 어떤 구현이 되어있는지 모르기 때문에 manager의 포인터 manager*를 쓴 것
  * 주소값만 가지고 있으면 됨
  * manager 크기에 관계 없이 공간의 크기가 정해짐 (Define이 만들어질 수 있음)
* employee*는 꼭 포인터가 안들어가도됨 (이미 정의가 되었기 때문)



## Nested Blocks

* 원래는 코드 맨 앞에 변수들을 선언해야만 했다.
* 하지만 최근 언어들은 나중에 선언해도 됨! (Algol 68 , C99 , C's Descendants...)
* Java, C#는 함수 안에 똑같은 이름을 가진 변수가 여러개 있을 수 없다 (한번에 한개, 어떤 블럭이 존재하든 간에..)

```java
class Test{
    int x = 7;
    public void f() {
        int x = 5;
        {
            int x= 7; // Compile Error
        }
    }
}
```

* overhead : 추가로 시간이 걸리는 지?
* Nested Blocks 들도 함수가 시작될 때 Stack 영역에 할당된다. Scope영역만 안쪽으로 제한되는 것이지, 변수 공간은 Stack에 머무른다.
* Nested Block을 사용해도 Overhead를 걸리는건 아님, 그냥 함수가 시작할 때 미리 다 할당되는 것



## Modules

* information Hiding (은닉성)
  * 안에 안보이게 만들어서 겉에 보이는 interface만 사용하게 하는것 (캡슐화)
  * reducing cognitive load
  * reducing name conflicts
  * integrity of data abstraction(데이터 응집성(데이터 훼손))을 보호 - interface만 제공
  * runtime errors를 compartmentalize 한다.
    * 오류가 발생시, 해당 모듈부터 확인해서 디버깅 시간을 단축시킴
* Cognitive load (인지부화) - 머리에 부담을 덜 주겠다!, 시스템에 주어진 부분을 이해하는데 있어서 필요한 정보를 최소화 시키겠다
  * 프로그래밍 하는 사람에게 인지부조화 시키겠다? 뭔개소리야
  * 즉 사람 머릿속에 들어오는 정보를 최소화 시킨다는 말?
* 모듈은 최대한 간단하게 만들어야한다
  * 기술이 발전하면서 기기를 작게 만들고 싸게 만들면서 똑같은 기능을 제공할 수 있게 됨 (interface가 똑같다)

* Encapsulating Data and Subroutines
  * Module - 데이터와 함수를 캡슐화 시키는 작업!
  * Lifetime은 일반 함수와 비슷함!
    * Nested Subroutine <<
  * 1개 이상의 subroutine 을 사용해야되는 경우에는 abstraction을 구현하는 것을 허용 X (static으로는 불가)
    * 따라서 모듈이라는 것이 필요
* 모듈은 Abstraction을 제공해 줄 수 있다.
  * 안에 뭐가 담겨있는지는 알려주지 않고, interface 함수만 알려준다.
  * 모듈 안에 있는 object 들은 서로 볼 수 있다(subroutine,type,var)
  * 안쪽에 있는 object들은 바깥쪽에서 안보일 수 있다. (May Not) (Export 되지 않는 이상 안보임)
  * 모듈 바깥에 있는 object들은 안쪽에서 안보일 수 있따. (May Not) (Import 과정을 거쳐야 한다.)
  * Visibility(접근성)에 대해서만 관여한다
* Java에서 Package 는 약간 module 같지만 살짝 열려있는 개념이다.

```c
// a.c 
void f(){
    static c;
}
// b.c
void g(){
    static c;
}
```

* c언어의 분할 컴파일해주는 기능을 가지고 Module을 흉내낼 수 있음



* In C++

  * ```C++
    namespace rand_mod{
        unsigned int seed = time(0);
        const unsigned int a = 48721;
        const unsigned int m = 0xffffff;
        void set_seed(unsigned int s){
            seed = s;
        }
        unsigned int rand_int(){
            return seed = (a*seed)%m;
        }
    }
    
    namespace rand_mod_2{
        unsigned int seed = time(0);
        void set_seed(unsigned int s){
            seed = s;
        }
        ...
    }
    ```

    * rand_mod 안에 있는 애들은 namespace 안에만! 존재
    * 이런 경우에는 이름충돌을 일으키지 않는다!
    * 일종의 모듈처럼 볼 수 있따.

  * Name psace 안에 있는 이름들의 바인딩은, namespace 바깥쪽에 안보일 수 도 있다. (완전히 안보이는 것은 아님,사라지지는 않음!)

  * seed라는 변수는 유지한다. program 시작~끝까지 값이 유지가 된다. 하지만 set_seed,rand_int 함수 내에서만 보인다!

    * 바깥에서 접근할 떄에는 `rand_mod::seed, rand_mod::set_seed()` 이런식으로 접근 가능함 ==> 완전 개방형!
    * Namespace 처럼 감춰놓은 것 처럼 보이지만 사실상 다 보임ㅋ --> Export , import 개념이 필요없음
    * 따라서 좀 모듈이라 하기엔 애매~ 함

  * `using rand_mod::rand_int`; 라고 하면 `int r = rand_int();` 이렇게 사용가능하다.

* wholesale exposure(완전 개방형) 이면 이름에 대한 conflict가 생길 수 있다.

> 좀 정리가 개판일 수 있는데, 교수님 설명이 너무 어려워서 조금 개판처럼 적음