# 4주차 강의

## Declaration and Definitions

```c
/* extern 이 빠져있다고 생각해도 됨 */ void g();  //Declaration
void f(){  //Definition
    g();
}
void g(){
    f();
}
```

* Declaration 은 어떤 입력, 반환값, 이름만 미리 알려주는 것
* Definition 은 실제 구현 정보

* f()는 선언과 정의를 동시에 함

```c
struct manager; // delcaration
struct employee{ // definition
    struct manager* boss;
    struct employee* next_employee;
}
struct manager{
    struct employee* first_employee
}
```

* 이 경우 manager가 어떤 구현이 되어있는지 모르기 때문에 manager의 포인터 manager*를 쓴 것
  * 주소값만 가지고 있으면 됨
  * manager 크기에 관계 없이 공간의 크기가 정해짐 (Define이 만들어질 수 있음)
* employee*는 꼭 포인터가 안들어가도됨 (이미 정의가 되었기 때문)



## Nested Blocks

* 원래는 코드 맨 앞에 변수들을 선언해야만 했다.
* 하지만 최근 언어들은 나중에 선언해도 됨! (Algol 68 , C99 , C's Descendants...)
* Java, C#는 함수 안에 똑같은 이름을 가진 변수가 여러개 있을 수 없다 (한번에 한개, 어떤 블럭이 존재하든 간에..)

```java
class Test{
    int x = 7;
    public void f() {
        int x = 5;
        {
            int x= 7; // Compile Error
        }
    }
}
```

* overhead : 추가로 시간이 걸리는 지?
* Nested Blocks 들도 함수가 시작될 때 Stack 영역에 할당된다. Scope영역만 안쪽으로 제한되는 것이지, 변수 공간은 Stack에 머무른다.
* Nested Block을 사용해도 Overhead를 걸리는건 아님, 그냥 함수가 시작할 때 미리 다 할당되는 것



## Modules

* information Hiding (은닉성)
  * 안에 안보이게 만들어서 겉에 보이는 interface만 사용하게 하는것 (캡슐화)
  * reducing cognitive load
  * reducing name conflicts
  * integrity of data abstraction(데이터 응집성(데이터 훼손))을 보호 - interface만 제공
  * runtime errors를 compartmentalize 한다.
    * 오류가 발생시, 해당 모듈부터 확인해서 디버깅 시간을 단축시킴
* Cognitive load (인지부화) - 머리에 부담을 덜 주겠다!, 시스템에 주어진 부분을 이해하는데 있어서 필요한 정보를 최소화 시키겠다
  * 프로그래밍 하는 사람에게 인지부조화 시키겠다? 뭔개소리야
  * 즉 사람 머릿속에 들어오는 정보를 최소화 시킨다는 말?
* 모듈은 최대한 간단하게 만들어야한다
  * 기술이 발전하면서 기기를 작게 만들고 싸게 만들면서 똑같은 기능을 제공할 수 있게 됨 (interface가 똑같다)

* Encapsulating Data and Subroutines
  * Module - 데이터와 함수를 캡슐화 시키는 작업!
  * Lifetime은 일반 함수와 비슷함!
    * Nested Subroutine <<
  * 1개 이상의 subroutine 을 사용해야되는 경우에는 abstraction을 구현하는 것을 허용 X (static으로는 불가)
    * 따라서 모듈이라는 것이 필요
* 모듈은 Abstraction을 제공해 줄 수 있다.
  * 안에 뭐가 담겨있는지는 알려주지 않고, interface 함수만 알려준다.
  * 모듈 안에 있는 object 들은 서로 볼 수 있다(subroutine,type,var)
  * 안쪽에 있는 object들은 바깥쪽에서 안보일 수 있다. (May Not) (Export 되지 않는 이상 안보임)
  * 모듈 바깥에 있는 object들은 안쪽에서 안보일 수 있따. (May Not) (Import 과정을 거쳐야 한다.)
  * Visibility(접근성)에 대해서만 관여한다
* Java에서 Package 는 약간 module 같지만 살짝 열려있는 개념이다.

```c
// a.c 
void f(){
    static c;
}
// b.c
void g(){
    static c;
}
```

* c언어의 분할 컴파일해주는 기능을 가지고 Module을 흉내낼 수 있음



* In C++

  * ```C++
    namespace rand_mod{
        unsigned int seed = time(0);
        const unsigned int a = 48721;
        const unsigned int m = 0xffffff;
        void set_seed(unsigned int s){
            seed = s;
        }
        unsigned int rand_int(){
            return seed = (a*seed)%m;
        }
    }
    
    namespace rand_mod_2{
        unsigned int seed = time(0);
        void set_seed(unsigned int s){
            seed = s;
        }
        ...
    }
    ```

    * rand_mod 안에 있는 애들은 namespace 안에만! 존재
    * 이런 경우에는 이름충돌을 일으키지 않는다!
    * 일종의 모듈처럼 볼 수 있따.

  * Name psace 안에 있는 이름들의 바인딩은, namespace 바깥쪽에 안보일 수 도 있다. (완전히 안보이는 것은 아님,사라지지는 않음!)

  * seed라는 변수는 유지한다. program 시작~끝까지 값이 유지가 된다. 하지만 set_seed,rand_int 함수 내에서만 보인다!

    * 바깥에서 접근할 떄에는 `rand_mod::seed, rand_mod::set_seed()` 이런식으로 접근 가능함 ==> 완전 개방형!
    * Namespace 처럼 감춰놓은 것 처럼 보이지만 사실상 다 보임ㅋ --> Export , import 개념이 필요없음
    * 따라서 좀 모듈이라 하기엔 애매~ 함

  * `using rand_mod::rand_int`; 라고 하면 `int r = rand_int();` 이렇게 사용가능하다.

* wholesale exposure(완전 개방형) 이면 이름에 대한 conflict가 생길 수 있다.

> 좀 정리가 개판일 수 있는데, 교수님 설명이 너무 어려워서 조금 개판처럼 적음



## Imports and Exports

* Exports and Import

  * 일부 언어들 중, 모듈에서 어떤 것(사용할 수 있는 부분)들을 갖다가 Export 시킬 수 있다.
  * 제한적인 용법으로 Export
    * 변수는 Read-only 하게 읽게 하던지.. 언어마다 차이가 있음
  * Type을 opaquely(transparent) 하게 export 할 수 있다. (불투명한 케이스)
    * `export struct A;` : A가 뭘 가지고 있는지는 모름..! (바깥에서 쓰는 사람의 경우)
  * Closed Scopes(사용하는 사람 관점)
    * 내가 이름을 사용해야하는데.. 반드시 import을 써야해...! --> Close Scopes
    * `import java.util.random;` : Closed scopes
  * Open Scopes
    * 반드시 import 를 안해도돼..
    * `import java.util.*;`
  * 자동으로 export 되는 이름인 경우
    * 모듈의 이름을 가지고 쓸 때, 사용할 수 있다. 안되면 import 를 명시해야함
    * (C++인 경우 `Using`..)

* Modules as Managers

  * 모듈을 가져다 쓸 때, single Abstraction을 define 한다. 

  * 여러개의 인스턴스를 만드는게 불가능 (pseudorandom)

  * Solution

    * Module Code를 복사 --> 새로운 이름을 붙인다
    * 내부 구조 자체를 바꾼다. (한개 만이 아닌 여러개가 존재할 수 있도록 만듬) --> 여러개를 관리하는 것을 추상화 시킨다..
    * 모듈을 type으로 처리한다 (Simula,Euclid, and ML)
      * Like .. Class의 개념

  * Pseudorandom generator Manager Example

    * Manager(생성자)를 여러개 둘 수 있게 한다

    * ``` C++
      #include <time.h>
      namespace rand_mgr{
          const unsigned int a = 48271;
          const unsigned int m = 0xfffff;
          struct generator {
              unsigned int seed;
          };
          generator* create(){
              generator* g= new generator; // generator 구조체 생성, 포인터변수를 만듬
              g-> seed = time(0); // 그 구조체 안에 값 셋팅
              return g;
          }
          void set_seed(generator* g, unsigned int s){
              g -> seed = s; // 어떤 generator에 해당하는 지를 받아서, 그 generator 안에 있는 seed 값을 셋팅
          }
          unsigned int rand_int (generator* g){ // 어떤 generator를 받아서, 그 generator 안에 seed를 셋팅,사용
              return g-> seed = (a * g -> seed) %m 
          }
      }
      using rand_mgr::generator;
      generator* g1 = rand_mgr::create();
      generator* g2 = rand_mgr::create();
      
      using rand_mgr::rand_int;
      int r1 = rand_int(g1); //각기 다른 시드를 갖고있음
      int r2 = rand_int(g2);
      ```

    * ```c++
      //Euclid 방식과 비슷, 모듈을 type으로 간주
      class rand_gen{
          unsigned int seed= time(0);
          const unsigned int a = 48271;
          const unsigned int m = 0x7ffff;
      }
      public:
      	void set_seed(unsigned int s){
              seed = s;
          }
      	unsigned int rand_int(){
              return seed = (a*seed)%m;
          }
      };
      
      rand_gen 을 여러개 생성해서 관리..
      ```

* Object Orientation

  * 객체 지향에서의 모듈 개념

    * Class와 Module types은 조금 다르다

      * Class는 상속, Dynamic method dispatch, Polymorphism.... 등 추가로 지원함
        * 기존 클래스를 확장한다거나, 기존 클래스를 세부적으로 조정 --> 상속
        * 부모클래스에 있는 함수인 것 처럼 호출해주는데, 실질적으로는 자식클래스의 함수를 호출 --> Dynamic Method dispatch 
      * Modules 은 Class를 포함하는 것! (좀 더 큰 범위)
        * C++ (namespace), Java (Package)..
        * 클래스는 완벽하게 모듈을 대체할 수 없다. (일부에 대해서는 대체 가능)
          * example : FPS 게임 (1인칭 게임)
            * 클래스들은 캐릭터,아이템,빌딩,목표.. 등등 클래스가 될 수 있음 (명사들)
            * 그래픽,렌더링 등등 이거는 Abstraction이 아니라 다른 개념 --> 클래스로 묶기는 애매함
            * 모듈이라고 클래스를 대체할 수도 없다.

    * Java의 모듈

      * 자바 9 부터 지원..
      * 패키지는 관련 있는 클래스들으 묶어서 관리할 수 있도록 함
        * private, protected, public 등 가시성을 부여
      * 패키지 내부 또는 외부에서 사용할 수 있는 클래스를 구별
      * 추상화와 캡슐화...
      * 패키지 특성이 오히려 추상화 캡슐화를 해치는 경우가 발생
      * Public 클래스를 숨길 수 있으므로 강한 캡슐화 지원
      * 모듈 단위로 추상화와 캡슐화를 지원함으로써 패키지 간의 관계를 모듈 단위로 정리할 수 있어 복잡한 의존성을 줄일 수 있음
      * 이미지,xml파일 같은 다른 리소스 파일들을 포함시킬 수 있음
      * 응용 프로그램을 모듈에 넣는 것 보다는 자주 사용될 수 있는 라이브러리를 구축할 때 더 유용함

      ```java
      //import
      module com.my.app.module{
          requires com.my.hello.module; //public class인 경우..
      }
      
      //export
      module com.my.hello.module{
          exports com.my.hello
      }
      ```

## Dynamic Scoping

* 실제 실행을 시켰을 때 binding을 알 수 있음 --> 실행 중에 scope 결정
* rules
  * 현재에 사용되고 있는 binding은 실행중에 **가장 최근에 마주친 변수(함수)** 이라고 생각하면됨

```pascal
n : integer 	-- global declaration (1)
procedure first()
	n := 1
procedure second()
	n : integer -- local declaration (2)
	first()

n := 2 			-- n = 2
if read_integer() > 0
	second()
else
	first()
write_integer(n)
//0 보다 작은 값이 들어오면 first --> 1을 출력 (static인 경우에는 둘 다 1을 출력)
/* Dynamic Scoping
r_i > 0 인 경우
second() 함수 호출 --> first() 함수 호출
이 경우 first() 에 있는 n은 second()에 있는 n을 가리킨다
하지만 second를 빠져나가면서 (2)는 사라진다.
따라서 W_i를 했을 때 n:=2 인 2가 나온다.

r_i < 0 인 경우
first() 함수 호출 --> n은 (1)을 가리킴
따라서 w_I를 헀을 때 1을 출력
*/
```

